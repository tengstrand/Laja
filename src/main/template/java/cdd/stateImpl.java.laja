
#macro stateMethods()
  #foreach (expandedAttribute in expandedAttributes)
    #stateMethod(expandedAttribute, "")
  #end
#end

#macro stateMethod(expandedAttribute, tab)

{tab}    public {expandedAttribute.stateClass} get{expandedAttribute.variableAsClass}State() {
{tab}        return new {expandedAttribute.stateClass}() {
{tab}            public Certificate certificate() { return certificate(); }
  #foreach (attribute in t.attributes)
{tab}            public {attribute.type} {attribute.getter}() { return {stateImplClass}.this.{attribute.getter}(); }
{tab}            public void {attribute.setter}({attribute.type} {attribute.variable}, Object mutator) { {stateImplClass}.this.{attribute.setter}({attribute.variable}, mutator); }

  #end
{tab}            public void encapsulate() { {stateImplClass}.this.encapsulate(); }
{tab}            public void setEncapsulator(Object encapsulator) { {stateImplClass}.this.setEncapsulator(encapsulator); }
##      #substateMethod(method.classname, tab)
  #isValid(t, "            ")
  #equals(t, "            ")
## fix!
##      #equalsState(t, "            ")
  #equalsValue(t, "            ")
  #hashCode(t, "            ")
  #toString(t, "            ")
{tab}        };
{tab}    }
#end

#macro gettersAndSetters()

    // Getters
  #foreach (attribute in attributes)
    public {attribute.type} {attribute.getter}() { return {attribute.variable}; }
  #end

    // Setters
  #foreach (attribute in attributes)
    #if (attribute.isStateSet || attribute.isStateList)
    public void {setter(attribute)} { checkMutator(mutator); this.{attribute.variable}.clear(); this.{attribute.variable}.addAll({attribute.variable}); }
    #else
    public void {setter(attribute)} { checkMutator(mutator); this.{attribute.variable} = {attribute.variable}; }
    #end
  #end
#end

#macro checkMutator()

    private void checkMutator(Object mutator) {
        if (mutator != _encapsulator) {
            throw new IllegalStateException("The state can only be mutated by current instance of " + (_encapsulator == null ? null : _encapsulator.getClass().getName()));
        }
    }

#end

#macro encapsulate()

    public void encapsulate() {
        _encapsulated = true;
    }
#end

#macro setEncapsulator()

    public void setEncapsulator(Object encapsulator) {
        _encapsulator = encapsulator;
    }
#end
#macro isValid(t, tab)

{tab}public boolean isValid() {
{tab}    return isValid(_encapsulated);
{tab}}

{tab}public boolean isValidAsEncapsulated() {
{tab}{tab}return isValid(true);
{tab}}

{tab}private boolean isValid(boolean encapsulated) {
  #set (hasMandatoryOrStateAttributes = false)
  #foreach (attribute in t.attributes where attribute.isMandatory && !attribute.isPrimitive)
    #set (hasMandatoryOrStateAttributes = true)
  #end
  #if (hasMandatoryOrStateAttributes)
    #set (delimiter = "")
    #set (nextDelimiter = "
           || ")
{tab}    if (##
    #foreach (attribute in t.attributes where !attribute.isPrimitive)
      #if (attribute.isMandatory)
        #if (attribute.isState)
            #if (attribute.isHidden)
{delimiter}(encapsulated && ({attribute.variable} == null || !{attribute.variable}.isValid()))##
          #else
{delimiter}({attribute.variable} == null || !{attribute.variable}.isValid())##
          #end
          #set (delimiter = nextDelimiter)
        #else
          #if (attribute.isHidden)
## If the attribute is hidden, the attribute is supposed to be set by the behaviour constructor
## and if isValid() is called before the state has been encapsulated then we don't check for null.
{delimiter}(encapsulated && {attribute.variable} == null)##
          #else
{delimiter}{attribute.variable} == null##
          #end
          #set (delimiter = nextDelimiter)
        #end
      #else if (attribute.isState)
{delimiter}({attribute.variable} != null && !{attribute.variable}.isValid())##
        #set (delimiter = nextDelimiter)
      #end
    #end
) {
{tab}        return false;
{tab}    }
  #end
  #foreach (expandedType in expandedTypes)
    #foreach (t2 in templates.values() where t2 != null && t2.classname == expandedType.type && t2.isValidStatement != null)
        if (!is{expandedType.type}Valid()) {
            return false;
        }
    #end
  #end
  #if (t.isValidStatement == null)
{tab}    return true;
  #else
    #set (statement = t.isValidStatement)
    ## Replace references to expanded types, e.g: a.b -> b
    #foreach (expandedType in expandedTypes)
      #foreach (t2 in templates.values() where t2 != null && t2.classname == expandedType.type)
        #foreach (attribute in t2.attributes)
          #set (statement = statementConverter.prefixAttribute("", statement, "{expandedType.variable}.{attribute.variable}", attribute.variable))
        #end
      #end
    #end
{tab}    {statement}
  #end
{tab}}
  #if (expandedTypes.size() > 0)
    #foreach (expandedType in expandedTypes)
      #foreach (t2 in templates.values() where t2 != null && t2.classname == expandedType.type && t2.isValidStatement != null)

    private boolean is{expandedType.type}Valid() {
        {t2.isValidStatement}
    }
      #end
    #end
  #end
#end

#function valueAttributes(t)
  #set (keys = new java.util.ArrayList())
  #foreach (attribute in t.attributes where !attribute.isExclude || attribute.isInclude)
    #keys.add(attribute)
  #end
  #return keys
#end

#function valueKeyAttributes(t)
  #set (keys = new java.util.ArrayList())
  #foreach (attribute in t.attributes where !attribute.isExclude && !attribute.isStateSet && !attribute.isStateList)
    #keys.add(attribute)
  #end
  #return keys
#end

#function entityAttributes(t)
  #set (keys = new java.util.ArrayList())
  #foreach (attribute in t.attributes where attribute.isKey || attribute.isInclude)
    #keys.add(attribute)
  #end
  #if (keys.size == 0)
    #return valueKeyAttributes(t)
  #end
  #return keys
#end

#macro equalsState(t, tab)

{tab}public boolean equalsState({stateClass} that) {
  #equalsBody(t, entityAttributes(t), "that", tab)
#end

#macro equals(t, tab)

{tab}@Override
{tab}public boolean equals(Object that) {
{tab}   if (this == that) return true;
{tab}   if (!(that instanceof {stateComparable})) return false;

## fix!
{tab}   return true;
##{tab}   return (({stateComparable})that).equalsState(this);
{tab}}
#end

#macro equalsValue(t, tab)

{tab}public boolean equalsValue(Object value) {
  #equalsBody(t, valueAttributes(t), "value", tab)
#end

#macro equalsBody(t, attributes, argument, tab)
  #if (attributes.isEmpty)
{tab}    return super.equals({argument});
  #else
{tab}    if (this == {argument}) return true;
{tab}    if ({argument} == null || getClass() != {argument}.getClass()) return false;

{tab}    {t.stateImplClass} state = ({t.stateImplClass}){argument};

    #foreach (attribute in attributes)
      #if (attribute.isPrimitive)
{tab}    if ({attribute.variable} != state.{attribute.getter}()) return false;
      #else
{tab}    if ({attribute.variable} != null ? !{attribute.variable}.equals(state.{attribute.variable}) : state.{attribute.variable} != null) return false;
      #end
    #end

{tab}    return true;
  #end
{tab}}
#end

#macro hashCode(t, tab)

{tab}@Override
{tab}public int hashCode() {
  #hashCodeBody(t, entityAttributes(t), tab)
#end

#macro hashCodeBody(t, attributes, tab)
  #if (attributes.isEmpty)
{tab}    return super.hashCode();
  #else
    #set (first = true)
    #set (intTypes = ["byte", "char", "short", "int"])
    #set (castTypes = ["float", "double"])
    #foreach (attribute in attributes)
      #if (first)
        #if (intTypes.contains(attribute.type))
{tab}    int result = {attribute.variable};
        #else if (castTypes.contains(attribute.type))
{tab}    int result = (int){attribute.variable};
        #else if (attribute.type == "long")
{tab}    int result = (int)({attribute.variable} ^ ({attribute.variable} >>> 32));
        #else if (attribute.type == "boolean")
{tab}    int result = {attribute.variable} ? 1 : 0;
        #else
{tab}    int result = {attribute.variable} != null ? {attribute.variable}.hashCode() : 0;
        #end
      #else
        #if (intTypes.contains(attribute.type))
{tab}    result = 31 * result + {attribute.variable};
        #else if (castTypes.contains(attribute.type))
{tab}    result = 31 * result + (int){attribute.variable};
        #else if (attribute.type == "long")
{tab}    result = (int)({attribute.variable} ^ ({attribute.variable} >>> 32));
        #else if (attribute.type == "boolean")
{tab}    result = 31 * result + ({attribute.variable} ? 1 : 0);
        #else
{tab}    result = 31 * result + ({attribute.variable} != null ? {attribute.variable}.hashCode() : 0);
        #end
      #end
    #set (first = false)
  #end

{tab}    return result;
  #end
{tab}}
#end

#macro toString(t, tab)

{tab}@Override
{tab}public String toString() {
  #set (iterator = t.attributes.iterator())
  #set (hasNext = iterator.hasNext)
  #set (first = true)
  #if (hasNext)
    #set (attribute = iterator.next)
  #end
  #while (hasNext)
    #set (hasNext = iterator.hasNext)
    #set (value = attribute.variable)
    #if (hasNext)
      #if (first)
        #if (attribute.type == "String")
{tab}    return "{{attribute.variable}=" + ({value} == null ? null : '\'' + {value} + '\'' ) +
        #else
{tab}    return "{{attribute.variable}=" + {value} +
        #end
      #else
        #if (attribute.type == "String")
{tab}            ", {attribute.variable}=" + ({value} == null ? null : '\'' + {value} + '\'' ) +
        #else
{tab}            ", {attribute.variable}=" + {value} +
        #end
      #end
      #set (attribute = iterator.next)
    #else
      #if (first)
{tab}    return "{{attribute.variable}=" + {value} + "}";
      #else
        #if (attribute.type == "String")
{tab}            ", {attribute.variable}='" + {value} + '\'' + "}";
        #else
{tab}            ", {attribute.variable}=" + {value} + "}";
        #end
      #end
    #end
    #set (first = false)
  #end
{tab}}
#end

#macro class()
  #header()
public class {stateImplClass} implements {stateClass} {
  #declareAttributes()

    private boolean _encapsulated = false;
    private Object _encapsulator;
  #stateMethods()

    {stateImplClass}() {
  #foreach (attribute in attributes where attribute.isStateSet && attribute.isStateList && !attribute.isExplicitAssigned)
        {attribute.variable} = {attribute.typeAsStateImpl}.emptyList();
  #end
  #foreach (attribute in attributes where attribute.isStateSet && !attribute.isExplicitAssigned)
        {attribute.variable} = {attribute.typeAsStateImpl}.emptySet();
  #end
    }

    public {stateImplClass}(Certificate certificate) {
        this();
        if (certificate == null) {
            throw new IllegalArgumentException("Certificate can not be null");
        }
    }

    public static {builderClass} build() {
        return new {builderImplClass}();
    }

    public static {builderClass} build({stateClass} state) {
        return new {builderImplClass}(state);
    }

    public Certificate certificate() {
        return Certificate.get(this);
    }
  #isValid($, "    ")
  #gettersAndSetters()
  #checkMutator()
  #encapsulate()
  #setEncapsulator()
  #equals($, "    ")
## fix!
##  #equalsState($, "    ")
  #equalsValue($, "    ")
  #hashCode($, "    ")
  #toString($, "    ")
}
#end

#macro importStateExpansion()
  #foreach (attribute in expandedAttributes)
    #set (t = templates.get(attribute.cleanedStateType))
    #if (t != null)
import {t.packagename}.{attribute.type};
    #end
  #end
#end

#macro fileContent()
  #package()
  #importBegin(false)
  #importState()
  #importStateExpansion()
  #importStateHashSet()
  #importStateArrayList()
  #importCertificate()
  #importEnd()
  #class()
#end

#set (filename = "{outputDir}/{stateImplClass}.java")
#generateFile(filename, fileContent())
