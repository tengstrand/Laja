
#macro stateProjections()
  #foreach (stateMethod in stateMethods)
    #foreach (template in templates.values() where template.classname == stateMethod.classname)
      #stateProjection(template, stateMethod)
    #end
  #end
#end

#macro stateProjection(t, stateArg)
  #set (method = new net.sf.laja.parser.cdd.StateProjectionMethod(stateArg))

    public {method.returnclass} {method.getter}() {
        return new {method.returnclass}() {
            public Certificate certificate() { return certificate(); }
      #foreach (attribute in t.attributes)
        #set (statement = method.getStatement(attribute.variable))
        #if (statement == null)
          #errors.addMessage("Could not find attribute '{attribute.variable}' in method '{stateClass}.{method.getter}'.")
          #set (msg = "/* missing attribute '{attribute.variable}' */")
          #if (attribute.isPrimitive)
            #if (attribute.type == "boolean")
              #set (getStatement = "false; {msg}")
            #else if (attribute.type == "char")
              #set (getStatement = "' '; {msg}")
            #else
              #set (getStatement = "0; {msg}")
            #end
          #else
            #set (getStatement = "null; {msg}")
          #end
          #set (setStatement = msg)
        #else
          #set (getStatement = "{stateImplClass}.this.{statement};")
          #set (setStatement = statementConverter.calculateSetStatement(statement, attribute.variable))
          #println("statement = {statement} attribute.variable={attribute.variable} setStatement={setStatement}")
          #set (setStatement = "{stateImplClass}.this.{setStatement};")
        #end
            public {attribute.type} {attribute.getter}() { return {getStatement} }
            public void {attribute.setter}({attribute.type} {attribute.variable}, Object mutator) { {setStatement} }

      #end
            public void encapsulate() { {stateImplClass}.this.encapsulate(); }
            public void setEncapsulator(Object encapsulator) { {stateImplClass}.this.setEncapsulator(encapsulator); }
      #isValid(t, true, "            ")
      #equals(t, true, "            ")
## fix!
##      #equalsState(t, true, "            ")
      #equalsValue(t, true, "            ")
      #hashCode(t, true, "            ")
      #toString(t, true, "            ")
        };
    }
#end

#macro gettersAndSetters()

    // Getters
  #foreach (attribute in attributes)
    public {attribute.type} {attribute.getter}() { return {attribute.variable}; }
  #end

    // Setters
  #foreach (attribute in attributes)
    #if (attribute.isStateSet || attribute.isStateList)
    public void {setter(attribute)} { checkMutator(mutator); this.{attribute.variable}.clear(); this.{attribute.variable}.addAll({attribute.variable}); }
    #else
    public void {setter(attribute)} { checkMutator(mutator); this.{attribute.variable} = {attribute.variable}; }
    #end
  #end
#end

#macro checkMutator()

    private void checkMutator(Object mutator) {
        if (mutator != _encapsulator) {
            throw new IllegalStateException("The state can only be mutated by current instance of " + (_encapsulator == null ? null : _encapsulator.getClass().getName()));
        }
    }

#end

#macro encapsulate()

    public void encapsulate() {
        _encapsulated = true;
    }
#end

#macro setEncapsulator()

    public void setEncapsulator(Object encapsulator) {
        _encapsulator = encapsulator;
    }
#end
#macro isValid(t, useGetter, tab)

{tab}public boolean isValid() {
{tab}    return isValid(_encapsulated);
{tab}}

{tab}public boolean isValidAsEncapsulated() {
{tab}{tab}return isValid(true);
{tab}}

{tab}private boolean isValid(boolean encapsulated) {
  #set (hasMandatoryOrStateAttributes = false)
  #foreach (attribute in t.attributes where attribute.isMandatory && !attribute.isPrimitive)
    #set (hasMandatoryOrStateAttributes = true)
  #end
  #if (hasMandatoryOrStateAttributes)
    #set (delimiter = "")
    #set (nextDelimiter = "
           || ")
{tab}    if (##
    #foreach (attribute in t.attributes where !attribute.isPrimitive)
      #if (attribute.isMandatory)
        #if (attribute.isState)
          #if (useGetter)
            #if (attribute.isHidden)
{delimiter}(encapsulated && ({attribute.getter}() == null || !{attribute.getter}().isValid()))##
            #else
{delimiter}({attribute.getter}() == null || !{attribute.getter}().isValid())##
            #end
          #else
            #if (attribute.isHidden)
{delimiter}(encapsulated && ({attribute.variable} == null || !{attribute.variable}.isValid()))##
            #else
{delimiter}({attribute.variable} == null || !{attribute.variable}.isValid())##
            #end
          #end
          #set (delimiter = nextDelimiter)
        #else
          #if (useGetter)
            #if (attribute.isHidden)
{delimiter}(encapsulated && {attribute.getter}() == null)##
            #else
{delimiter}{attribute.getter}() == null##
            #end
          #else
            #if (attribute.isHidden)
## If the attribute is hidden, the attribute is supposed to be set by the behaviour constructor
## and if isValid() is called before the state has been encapsulated then we don't check for null.
{delimiter}(encapsulated && {attribute.variable} == null)##
            #else
{delimiter}{attribute.variable} == null##
            #end
          #end
          #set (delimiter = nextDelimiter)
        #end
      #else if (attribute.isState)
        #if (useGetter)
{delimiter}({attribute.getter}() != null && !{attribute.getter}().isValid())##
        #else
{delimiter}({attribute.variable} != null && !{attribute.variable}.isValid())##
        #end
        #set (delimiter = nextDelimiter)
      #end
    #end
) {
{tab}        return false;
{tab}    }
  #end
  #foreach (expandedType in expandedTypes)
    #foreach (t2 in templates.values() where t2 != null && t2.classname == expandedType.type && t2.isValidStatement != null)
        if (!is{expandedType.type}Valid()) {
            return false;
        }
    #end
  #end
  #if (t.isValidStatement == null)
{tab}    return true;
  #else
    #set (statement = t.isValidStatement)
    ## Replace references to expanded types, e.g: a.b -> b
    #foreach (expandedType in expandedTypes)
      #foreach (t2 in templates.values() where t2 != null && t2.classname == expandedType.type)
        #foreach (attribute in t2.attributes)
          #set (statement = statementConverter.prefixAttribute("", statement, "{expandedType.variable}.{attribute.variable}", attribute.variable))
        #end
      #end
    #end
{tab}    {statement}
  #end
{tab}}
  #if (expandedTypes.size() > 0)
    #foreach (expandedType in expandedTypes)
      #foreach (t2 in templates.values() where t2 != null && t2.classname == expandedType.type && t2.isValidStatement != null)

    private boolean is{expandedType.type}Valid() {
        {t2.isValidStatement}
    }
      #end
    #end
  #end
#end

#function valueAttributes(t)
  #set (keys = new java.util.ArrayList())
  #foreach (attribute in t.attributes where !attribute.isExclude || attribute.isInclude)
    #keys.add(attribute)
  #end
  #return keys
#end

#function valueKeyAttributes(t)
  #set (keys = new java.util.ArrayList())
  #foreach (attribute in t.attributes where !attribute.isExclude && !attribute.isStateSet && !attribute.isStateList)
    #keys.add(attribute)
  #end
  #return keys
#end

#function entityAttributes(t)
  #set (keys = new java.util.ArrayList())
  #foreach (attribute in t.attributes where attribute.isKey || attribute.isInclude)
    #keys.add(attribute)
  #end
  #if (keys.size == 0)
    #return valueKeyAttributes(t)
  #end
  #return keys
#end

#macro equalsState(t, useGetter, tab)

{tab}public boolean equalsState({stateClass} that) {
  #equalsBody(t, entityAttributes(t), useGetter, "that", tab)
#end

#macro equals(t, useGetter, tab)

{tab}@Override
{tab}public boolean equals(Object that) {
{tab}   if (this == that) return true;
{tab}   if (!(that instanceof {stateComparable})) return false;

## fix!
{tab}   return true;
##{tab}   return (({stateComparable})that).equalsState(this);
{tab}}
#end

#macro equalsValue(t, useGetter, tab)

{tab}public boolean equalsValue(Object value) {
  #equalsBody(t, valueAttributes(t), useGetter, "value", tab)
#end

#macro equalsBody(t, attributes, useGetter, argument, tab)
  #if (attributes.isEmpty)
{tab}    return super.equals({argument});
  #else
{tab}    if (this == {argument}) return true;
{tab}    if ({argument} == null || getClass() != {argument}.getClass()) return false;

    #if (useGetter)
{tab}    {t.packagename}.{t.stateClass} state = ({t.packagename}.{t.stateClass}){argument};
    #else
{tab}    {t.stateImplClass} state = ({t.stateImplClass}){argument};
    #end

    #foreach (attribute in attributes)
      #set (variable = variable(useGetter))
      #if (attribute.isPrimitive)
{tab}    if ({variable} != state.{attribute.getter}()) return false;
      #else
        #if (useGetter)
{tab}    if ({variable} != null ? !{variable}.equals(state.{attribute.getter}()) : state.{attribute.getter}() != null) return false;
        #else
{tab}    if ({variable} != null ? !{attribute.variable}.equals(state.{attribute.variable}) : state.{attribute.variable} != null) return false;
        #end
      #end
    #end

{tab}    return true;
  #end
{tab}}
#end

#macro variable(useGetter)
  #if (useGetter)
    #set (statement = method.getStatement(attribute.variable))
    #if (statement != null)
{statement}##
    #else
{attribute.variable}##
    #end
  #else
{attribute.variable}##
  #end
#end

#macro hashCode(t, useGetter, tab)

{tab}@Override
{tab}public int hashCode() {
  #hashCodeBody(t, entityAttributes(t), useGetter, tab)
#end

#macro hashCodeBody(t, attributes, useGetter, tab)
  #if (attributes.isEmpty)
{tab}    return super.hashCode();
  #else
    #set (first = true)
    #set (intTypes = ["byte", "char", "short", "int"])
    #set (castTypes = ["float", "double"])
    #foreach (attribute in attributes)
      #set (variable = variable(useGetter))
      #if (first)
        #if (intTypes.contains(attribute.type))
{tab}    int result = {variable};
        #else if (castTypes.contains(attribute.type))
{tab}    int result = (int){variable};
        #else if (attribute.type == "long")
{tab}    int result = (int)({variable} ^ ({variable} >>> 32));
        #else if (attribute.type == "boolean")
{tab}    int result = {variable} ? 1 : 0;
        #else
{tab}    int result = {variable} != null ? {variable}.hashCode() : 0;
        #end
      #else
        #if (intTypes.contains(attribute.type))
{tab}    result = 31 * result + {variable};
        #else if (castTypes.contains(attribute.type))
{tab}    result = 31 * result + (int){variable};
        #else if (attribute.type == "long")
{tab}    result = (int)({variable} ^ ({variable} >>> 32));
        #else if (attribute.type == "boolean")
{tab}    result = 31 * result + ({variable} ? 1 : 0);
        #else
          #if (useGetter)
{tab}    result = 31 * result + ({variable} != null ? {variable}.hashCode() : 0);
          #else
{tab}    result = 31 * result + ({variable} != null ? {variable}.hashCode() : 0);
          #end
        #end
      #end
    #set (first = false)
  #end

{tab}    return result;
  #end
{tab}}
#end

#macro toString(t, useGetter, tab)

{tab}@Override
{tab}public String toString() {
  #set (iterator = t.attributes.iterator())
  #set (hasNext = iterator.hasNext)
  #set (first = true)
  #if (hasNext)
    #set (attribute = iterator.next)
  #end
  #while (hasNext)
    #set (hasNext = iterator.hasNext)
    #if (useGetter)
      #set (value = "{attribute.getter}()")
    #else
      #set (value = attribute.variable)
    #end
    #if (hasNext)
      #if (first)
        #if (attribute.type == "String")
{tab}    return "{{attribute.variable}=" + ({value} == null ? null : '\'' + {value} + '\'' ) +
        #else
{tab}    return "{{attribute.variable}=" + {value} +
        #end
      #else
        #if (attribute.type == "String")
{tab}            ", {attribute.variable}=" + ({value} == null ? null : '\'' + {value} + '\'' ) +
        #else
{tab}            ", {attribute.variable}=" + {value} +
        #end
      #end
      #set (attribute = iterator.next)
    #else
      #if (first)
{tab}    return "{{attribute.variable}=" + {value} + "}";
      #else
        #if (attribute.type == "String")
{tab}            ", {attribute.variable}='" + {value} + '\'' + "}";
        #else
{tab}            ", {attribute.variable}=" + {value} + "}";
        #end
      #end
    #end
    #set (first = false)
  #end
{tab}}
#end

#macro stateMethods()
  #foreach (attribute in expandedAttributes)
    #set (t = templates.get(attribute.cleanedStateType))
    #if (t == null)
      #errors.addMessage("Could not find state '{attribute.cleanedStateType}'")
    #else
      #stateProjection(t, t)
    #end
  #end
#end

#macro class()
  #header()
public class {stateImplClass} implements {stateClass} {
  #declareAttributes()

    private boolean _encapsulated = false;
    private Object _encapsulator;
  #stateProjections()

    {stateImplClass}() {
  #foreach (attribute in attributes where attribute.isStateSet && attribute.isStateList && !attribute.isExplicitAssigned)
        {attribute.variable} = {attribute.typeAsStateImpl}.emptyList();
  #end
  #foreach (attribute in attributes where attribute.isStateSet && !attribute.isExplicitAssigned)
        {attribute.variable} = {attribute.typeAsStateImpl}.emptySet();
  #end
    }

    public {stateImplClass}(Certificate certificate) {
        this();
        if (certificate == null) {
            throw new IllegalArgumentException("Certificate can not be null");
        }
    }

    public static {builderClass} build() {
        return new {builderImplClass}();
    }

    public static {builderClass} build({stateClass} state) {
        return new {builderImplClass}(state);
    }

    public Certificate certificate() {
        return Certificate.get(this);
    }
  #isValid($, false, "    ")
  #gettersAndSetters()
  #stateMethods()
  #checkMutator()
  #encapsulate()
  #setEncapsulator()
  #equals($, false, "    ")
## fix!
##  #equalsState($, false, "    ")
  #equalsValue($, false, "    ")
  #hashCode($, false, "    ")
  #toString($, false, "    ")
}
#end

#macro fileContent()
  #package()
  #importBegin(false)
  #importState()
  #importStateHashSet()
  #importStateArrayList()
  #importCertificate()
  #importEnd()
  #class()
#end

#set (filename = "{outputDir}/{stateImplClass}.java")
#generateFile(filename, fileContent())
