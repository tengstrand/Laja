
#macro newElements()
            {stateSetClass} newElements = new {stateHashSetClass}();
            for ({entryClass} element : collection) {
                newElements.add(element.getState(stateSet.certificate()));
            }
#end

#macro fileContent()
package {packagename};

import {statePackagename}.*;
import {behaviour.packagename}.*;
  #setImports()
import java.util.*;

  #header()
public class {hashSetClass} implements {setInterface}, RandomAccess, Cloneable, java.io.Serializable {
    protected {stateSetClass} stateSet;
    protected final Set<{entryClass}> set;

    public {hashSetClass}({entryClass}... array) {
        this.set = new HashSet<{entryClass}>();
        this.set.addAll(Arrays.asList(array));
    }

    public {hashSetClass}(Collection<{entryClass}> collection) {
        this.set = new HashSet<{entryClass}>();
        this.set.addAll(collection);
    }
  #if (method.isFactory)

    #setArgumentsAndParameters(method, true)
    public {hashSetClass}({stateSetClass} stateSet{parameters}) {
        this.stateSet = stateSet;
        this.stateSet.encapsulate(this);
        Set<{entryClass}> elements = new HashSet<{entryClass}>(stateSet.size());

        for ({stateClass} state : stateSet) {
            {stateBuilderClass} builder = new {stateBuilderImplClass}(state);
            {entryClass} entry = ({entryClass}) builder.as(new {factoryClass}.{entryClass}Factory_(){arguments});
            elements.add(entry);
        }
        this.set = new StateInSyncSet(stateSet, elements);
    }
  #end
  #foreach (m in asBehaviour.asMethods where m.methodName != method.methodName)
    #setArgumentsAndParameters(m, false)

    public {m.hashSetClass} {m.methodName}Set({parameters}) {
    #if (m.isFactory)
        if (stateSet != null) {
            return new {m.hashSetClass}(stateSet{extraArguments});
        }
    #end
        Set<{m.returnclass}> result = new HashSet<{m.returnclass}>();
        for ({entryClass} entry : set) {
            result.add(entry.{m.methodName}({arguments}));
        }
        return new {m.hashSetClass}(result);
    }
  #end

    public class StateInSyncSet extends HashSet<{entryClass}> {
        private {stateSetClass} stateSet;

        public StateInSyncSet({stateSetClass} stateSet, Set<{entryClass}> elements) {
            this.stateSet = stateSet;
            this.stateSet.clear();
            super.addAll(elements);
        }

        @Override
        public boolean add({entryClass} element) {
            stateSet.throwExceptionIfNotEncapsulatedBy({hashSetClass}.this);
            stateSet.add(element.getState(stateSet.certificate()));
            return super.add(element);
        }

        @Override
        public boolean addAll(Collection<? extends {entryClass}> collection) {
            stateSet.throwExceptionIfNotEncapsulatedBy({hashSetClass}.this);
            boolean modified = super.addAll(collection);

            for ({entryClass} element : collection) {
                stateSet.add(element.getState(stateSet.certificate()));
            }
            return modified;
        }

        @Override
        public boolean remove(Object element) {
            stateSet.throwExceptionIfNotEncapsulatedBy({hashSetClass}.this);
            if (!(element instanceof {entryClass})) {
                return false;
            }
            boolean removedState = stateSet.remove((({entryClass}) element).getState(stateSet.certificate()));
            boolean removedElement = super.remove(element);

            if (removedState != removedElement) {
                throw new IllegalStateException("The state and behaviour is out of sync. Please report this bug to the Laja project!");
            }
            return removedElement;
        }

        @Override
        public boolean removeAll(Collection<?> collection) {
            stateSet.throwExceptionIfNotEncapsulatedBy({hashSetClass}.this);
            Set states = new HashSet(collection.size());
            Set elements = new HashSet(collection.size());
            for (Object element : collection) {
                if (element instanceof {entryClass}) {
                    elements.add(element);
                    states.add((({entryClass})element).getState(stateSet.certificate()));
                }
            }
            boolean modified = super.removeAll(elements);
            stateSet.removeAll(states);

            return modified;
        }

        @Override
        public boolean retainAll(Collection<?> collection) {
            stateSet.throwExceptionIfNotEncapsulatedBy({hashSetClass}.this);
            Set states = new HashSet(collection.size());
            Set elements = new HashSet(collection.size());
            for (Object element : collection) {
                if (element instanceof {entryClass}) {
                    elements.add(element);
                    states.add((({entryClass})element).getState(stateSet.certificate()));
                }
            }
            boolean modified = super.retainAll(elements);
            stateSet.retainAll(states);

            return modified;
        }

        @Override
        public void clear() {
            stateSet.throwExceptionIfNotEncapsulatedBy({hashSetClass}.this);
            stateSet.clear();
            super.clear();
        }
    }

    public int size() {
        return set.size();
    }

    public boolean isEmpty() {
        return set.isEmpty();
    }

    public boolean contains(Object element) {
        return set.contains(element);
    }

    public Iterator<{entryClass}> iterator() {
        return set.iterator();
    }

    public Object[] toArray() {
        return set.toArray();
    }

    public <{entryClass}> {entryClass}[] toArray({entryClass}[] array) {
        return set.toArray(array);
    }

    public boolean add({entryClass} element) {
        return set.add(element);
    }

    public boolean addAll(Collection<? extends {entryClass}> collection) {
        return set.addAll(collection);
    }

    public boolean remove(Object element) {
        if (!(element instanceof {entryClass})) {
            return false;
        }
        return set.remove(element);
    }

    public boolean containsAll(Collection<?> collection) {
        return set.containsAll(collection);
    }

    public boolean removeAll(Collection<?> collection) {
        return set.removeAll(collection);
    }

    public boolean retainAll(Collection<?> collection) {
        return set.retainAll(collection);
    }

    public void clear() {
        set.clear();
    }

    @Override
    public boolean equals(Object o) {
        return set.equals(o);
    }

    @Override
    public int hashCode() {
        return set.hashCode();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{" + set + '}';
    }
}
#end

#foreach (method in behaviour.asMethods)
  #prepareCollection(outputDir, outDir)

  #if (!processedHashSets.contains(hashSetClass))
    #processedHashSets.add(hashSetClass)
    #if (!directoryExists(collectionOutputDir))
      #createDirectoryPath(collectionOutputDir)
    #end
    #set (filename = "{collectionOutputDir}/{hashSetClass}.java")
    #generateFile(filename, fileContent())
  #end
#end