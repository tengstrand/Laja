
#macro fileContent()
package {packagename};

import {template.packagename}.*;
      #foreach (m in asBehaviour.asMethods where m.methodName != method.methodName && m.generateList && !m.isFactory)
        #set (behaviourRef = behaviours.get(m.returnclass))
        #if (behaviourRef == null)
          #error ("Could not find behaviour class {m.returnclass}")
        #end
        #if (behaviourRef.packagename != packagename)

import {behaviourRef.packagename}.{m.returnclass};
import {behaviourRef.packagename}.{m.listClass};
        #end
      #end
      #if (!method.isFactory)
        #set (first = true)
        #foreach (m in behaviour.asMethods where m.isFactory && first)
          #set (behaviourRef = behaviours.get(m.returnclass))
          #if (behaviourRef.packagename != packagename)

import {behaviourRef.packagename}.{m.returnclass};
import {behaviourRef.packagename}.{m.returnclass}Factory;
          #end
          #set (first = false)
        #end
      #end

import java.util.*;

      #header()
public abstract class {abstractListClass} implements List<{entryClass}> {
    protected {stateListClass} stateList;
    protected final List<{entryClass}> list = new ArrayList<{entryClass}>();

    public {abstractListClass}({entryClass}... list) {
        this.list.addAll(Arrays.asList(list));
    }

    public {abstractListClass}(List<{entryClass}> list) {
        this.list.addAll(list);
    }

      #if (method.isFactory)

        #setArgumentsAndParameters(method, true)
    public {abstractListClass}({stateListClass} stateList{parameters}) {
        this.stateList = stateList;

        for ({stateClass} state : stateList) {
            {stateBuilderClass} builder = new {stateBuilderImplClass}(state);
            {entryClass} entry = ({entryClass}) builder.as(new {factoryClass}.{entryClass}Factory_(builder){arguments});
            list.add(entry);
        }
    }
      #end
      #foreach (m in asBehaviour.asMethods where m.methodName != method.methodName && m.generateList && !m.isFactory)
        #setArgumentsAndParameters(m, false)

    public {m.listClass} {m.methodName}List({parameters}) {
        List<{m.returnclass}> result = new ArrayList<{m.returnclass}>();
        for ({entryClass} entry : list) {
            result.add(entry.{m.methodName}({arguments}));
        }
        return new {m.listClass}(result);
    }
      #end

    public boolean isStateInSync() {
        if (stateList == null) {
            return true;
        }
        if (stateList.size() != list.size()) {
            return false;
        }
        for ({entryClass} element : list) {
            if (!element.contains(stateList) || !element.isStateInSync()) {
                return false;
            }
        }
        return true;
    }

    public boolean syncState() {
        if (isStateInSync()) {
            return false;
        }
        stateList.clear();

        for ({entryClass} entry : list) {
            entry.syncState();
            entry.addToList(stateList);
        }
        return true;
    }

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public boolean contains(Object element) {
        return list.contains(element);
    }

    public Iterator<{entryClass}> iterator() {
        return list.iterator();
    }

    public Object[] toArray() {
        return list.toArray();
    }

    public <{entryClass}> {entryClass}[] toArray({entryClass}[] array) {
        return list.toArray(array);
    }

    public boolean add({entryClass} element) {
        return list.add(element);
    }

    public void add(int index, {entryClass} element) {
        list.add(index, element);
    }

    public boolean addAll(Collection<? extends {entryClass}> collection) {
        return list.addAll(collection);
    }

    public boolean addAll(int index, Collection<? extends {entryClass}> collection) {
        return list.addAll(index, collection);
    }

    public boolean remove(Object element) {
        if (!(element instanceof {entryClass})) {
            return false;
        }
        return list.remove(element);
    }

    public boolean containsAll(Collection<?> collection) {
        return list.containsAll(collection);
    }

    public boolean removeAll(Collection<?> collection) {
        return list.removeAll(collection);
    }

    public boolean retainAll(Collection<?> collection) {
        return list.retainAll(collection);
    }

    public void clear() {
        list.clear();
    }

    public {entryClass} get(int index) {
        return list.get(index);
    }

    public {entryClass} set(int index, {entryClass} element) {
        return list.set(index, element);
    }

    public {entryClass} remove(int index) {
        return list.remove(index);
    }

    public int indexOf(Object element) {
        return list.indexOf(element);
    }

    public int lastIndexOf(Object element) {
        return list.lastIndexOf(element);
    }

    public ListIterator<{entryClass}> listIterator() {
        return list.listIterator();
    }

    public ListIterator<{entryClass}> listIterator(int index) {
        return list.listIterator(index);
    }

    public List<{entryClass}> subList(int fromIndex, int toIndex) {
        return list.subList(fromIndex, toIndex);
    }

    @Override
    public boolean equals(Object o) {
        return list.equals(o);
    }

    @Override
    public int hashCode() {
        return list.hashCode();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{list=" + list + '}';
    }
}
#end

#foreach (method in behaviour.asMethods where method.generateList)
  #prepareList(outputDir, outDir)

  #if (!processedAbstractLists.contains(abstractListClass))
    #processedAbstractLists.add(abstractListClass)
    #if (!directoryExists(listOutputDir))
      #createDirectoryPath(listOutputDir)
    #end
    #set (filename = "{listOutputDir}/{abstractListClass}.java")
    #generateFile(filename, fileContent())
  #end
#end