Composition is a great technique used to construct more complex objects in object oriented languages,
also known as ''aggregate'' in [http://en.wikipedia.org/wiki/Domain-driven_design Domain-driven Design]:


[[File:Traditional-object-composition.png|400px]]


Composition is often a better alternative than inheritance mainly because it's more modular
and lacks many of the quirks associated with inheritance.
Composition is the way this type of stateful objects is constructed in CDD.
The main difference compared to traditional object orientation is that each behaviour representation,
with all its sub behaviours, can be specialized for different contexts:


[[File:CDD-object-composition.png|400px]]


Let's start by composing a person state object with all its parts:
<source>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
    SizeState $size;
    AddressState address; // (optional)
    PersonStateList children; // (optional)
}
</source>

<source>
package com.myproject.state;

public class SizeStateTemplate {
    int heightCm;
    int weightKg;
}
</source>

<source>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;
    String city;
}
</source>

...when generated, empty behaviour implementations are created:
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }
}
</source>

<source>
package com.myproject.behaviour;

import com.myproject.state.AddressState;

public class Address extends AddressFactory {
    public Address(AddressState state) {
        super(state);
    }

    // (factory)
    public Address asAddress() {
        return new Address(state);
    }
}
</source>

<source>
package com.myproject.behaviour;

import com.myproject.state.SizeState;

public class Size extends SizeFactory {
    public Size(SizeState state) {
        super(state);
    }

    // (factory)
    public Size asSize() {
        return new Size(state);
    }
}
</source>

...let's se how the code behaves so far by executing:
<source>
Person person = Person.givenName("Anders").surname("Andersson").heightCm(179).weightKg(75)
        .withAddress(Address.streetName("First street").streetNumber(2).zipcode(123).city("Stockholm"))
        .withChildren(
                Person.givenName("Carl").surname("Andersson").heightCm(110).weightKg(20),
                Person.givenName("Eric").surname("Andersson").heightCm(130).weightKg(30)).asPerson();

System.out.println(person);
</source>

...output:
<source>
Person{givenName='Anders', surname='Andersson', heightCm=179, weightKg=75,
  address={streetName='First street', streetNumber=2, zipcode=123, city='Stockholm'},
  children=[{givenName='Carl', surname='Andersson', heightCm=110, weightKg=20, address=null, children=[]},
            {givenName='Eric', surname='Andersson', heightCm=130, weightKg=30, address=null, children=[]}]}
</source>

The size was marked as ''$size'' and therefore [[State expansion|expanded]] into the person state.
The attributes ''address'' and ''children'' was marked as ''optional'' and therefore populated by builder with-methods.


Let's add some behaviour to address:
<source>
package com.myproject.behaviour;

import com.myproject.state.AddressState;

public class Address extends AddressFactory {
    public Address(AddressState state) {
        super(state);
    }

    // (factory)
    public Address asAddress() {
        return new Address(state);
    }

    // Ullared is a small town in Sweden.
    public boolean isRegisteredInUllared() {
        return state.getZipcode() >= 31109 && state.getZipcode() <= 31185;
    }
}
</source>

Rename ''Size'' to ''BMI'' and replace it with this content (and regenerate to generate ''BMIFactory''):
<source>
package com.myproject.behaviour;

import com.myproject.state.SizeState;

import java.math.BigDecimal;
import java.math.RoundingMode;

public class BMI extends BMIFactory {
    public BMI(SizeState state) {
        super(state);
    }

    // (factory)
    public BMI asBMI() {
        return new BMI(state);
    }

    /**
     * @return body mass index with one decimal.
     */
    public double calculateBmi() {
        double heightInMeter = state.getHeightCm() / 100.0;
        double bmi = state.getWeightKg() / (heightInMeter * heightInMeter);
        return new BigDecimal(bmi).setScale(1, RoundingMode.HALF_EVEN).doubleValue();
    }

    public boolean hasNormalWeight() {
        double bmi = calculateBmi();
        return bmi >= 18.5 && bmi <= 24.9;
    }
}
</source>

Now that we have all the building blocks we need, it's time to put the pieces together:
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

import java.util.ArrayList;
import java.util.List;

public class Person extends PersonFactory {
    private final BMI bmi;
    private final Address address;
    private final PersonList children;

    public Person(PersonState state) {
        super(state);
        bmi = new BMI(state);
        address = new Address(state.getAddress());
        children = new PersonArrayList(state.getChildren());
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public String name() {
        return state.getGivenName() + " " + state.getSurname();
    }

    public boolean isRegisteredInUllared() {
        return address.isRegisteredInUllared();
    }

    public double calculateBmi() {
        return bmi.calculateBmi();
    }

    public boolean hasNormalWeight() {
        return bmi.hasNormalWeight();
    }

    public List<String> childrenNames() {
        List<String> names = new ArrayList<String>();
        for (Person child : children) {
            names.add(child.name());
        }
        return names;
    }
}
</source>

...if executed:

<source>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.givenName("Anders").surname("Andersson").heightCm(179).weightKg(75)
                .withAddress(Address.streetName("First street").streetNumber(2).zipcode(123).city("Stockholm"))
                .withChildren(
                        Person.givenName("Carl").surname("Andersson").heightCm(110).weightKg(20),
                        Person.givenName("Eric").surname("Andersson").heightCm(130).weightKg(30)).asPerson();

        System.out.println("Name: " + person.name());
        System.out.println("Body Mass Index: " + person.calculateBmi());
        System.out.println("Has normal weight: " + person.hasNormalWeight());
        System.out.println("Registered in Ullared: " + person.isRegisteredInUllared());
        System.out.println("Children: " + person.childrenNames());
    }
}
</source>

...we get the output:

<source>
Name: Anders Andersson
Body Mass Index: 23.4
Has normal weight: true
Registered in Ullared: false
Children: [Carl Andersson, Eric Andersson]
</source>


[[Collections|< Back]]
