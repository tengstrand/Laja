If a substate need to be populated by the behaviour class and if it can't be done by the sub-behaviour class itself (''Address'' in this example) it can be managed by the aggregate root itself (''Person''):
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode; // (hide)
}
</pre>

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
    AddressState address;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.AddressState;

public class Address extends AddressFactory {
    public Address(AddressState state) {
        super(state);
    }

    // (factory)
    public Address asAddress() {
        return new Address(state);
    }
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonStateBuilder;

public class Person extends PersonFactory {
    public Person(PersonState state, PersonStateBuilder stateBuilder) {
        super(state, stateBuilder);

        // Populate attribute "zipcode" in substate "address".
        stateBuilder.getAddressStateBuilder().withZipcode(123);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state, stateBuilder);
    }
}
</pre>

...if executed:
<pre>
    Person person = Person.givenName("Ingmar").surname("Bergman")
        .address(Address.streetName("Thestreet").streetNumber(1)).asPerson();

    System.out.println(person);
</pre>

...the zipcode is now 123:
<pre>
Person{givenName='Ingmar', surname='Bergman', address={streetName='Thestreet', streetNumber=1, zipcode=123}}
</pre>


We can choose between two constructors when implementing our behaviour representations, e.g.:
<pre>
    public Person(PersonState state)
    public Person(PersonState state, PersonStateBuilder stateBuilder)
</pre>

The second is used when we need to populate one or more substates from the aggregate root (as in this example).
Only one of the two constructors should be implemented at a time.

Remember that in most situations your first choice should be to either let the user of the class populate the attributes, alternatively using [[CDD - State - Default values|default values]].

=== Populating substate from the sub-behaviour ===
Let's see if instead we can populate ''zipcode'' from the behaviour class ''Address'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.AddressState;

public class Address extends AddressFactory {
    public Address(AddressState state) {
        super(state);
        state.setZipcode(123);
    }

    // (factory) (list)
    public Address asAddress() {
        return new Address(state);
    }
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory) (list)
    public Person asPerson() {
        return new Person(state);
    }
}
</pre>

...if regenerated and executed:
<pre>
    Person person = Person.givenName("Ingmar").surname("Bergman")
            .address(Address.streetName("Thestreet").streetNumber(1)).asPerson();

    System.out.println(person);
</pre>

...we get the output:
<pre>
Person{givenName='Ingmar', surname='Bergman', address={streetName='Thestreet', streetNumber=1, zipcode=0}}
</pre>

What happened here? Didn't we set the zipcode from ''Address''? The answer is no, the constructor of ''Address'' was never executed, but let's fix that:
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    private Address address;

    public Person(PersonState state) {
        super(state);
        address = new Address(state.getAddress());
    }

    // (factory) (list)
    public Person asPerson() {
        return new Person(state);
    }
}
</pre>

...output:
<pre>
Person{givenName='Ingmar', surname='Bergman', address={streetName='Thestreet', streetNumber=1, zipcode=123}}
</pre>

Voil√†! The zipcode was populated and we now also have the class member ''address'' that can be used by ''Person''.
That brings us naturally to the next exciting area ''composition''!


[[Populate state|< Back]]
