In our examples we have used ''Person'' as factory when creating instances of ''Person''. We could also have used the generated class ''PersonFactory'':
<source>
    Person person1 = PersonFactory.givenName("Ingmar").surname("Bergman").asPerson();
    Person person2 = PersonFactory.build().withGivenName("Ingmar").withSurname("Bergman").asPerson();
</source>

To make ''Person'' a factory we extend from ''PersonFactory'':
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</source>

Only the method that is marked as ''factory'' can be directly created by the factory class. If an "as-method" is not marked as factory then it has to be called via the factory method:
<source>
    PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPerson().asPersistable();
</source>

If we also mark ''asPersistable'' as factory:
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</source>

...we can create instances directly:
<source>
    PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPersistable();
</source>


In some situations we want the object themselves to act as factory:
<source>
    Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
    PersistablePerson persistablePerson = PersistablePerson.givenName("Ingmar").surname("Bergman").asPersistable();
</source>

...by letting the behaviour class inherit from its factory and include a factory method:

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // Behaviour is added here...
}
</source>

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class PersistablePerson extends PersistablePersonFactory {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    // Behaviour is added here...
}
</source>


It's not mandatory to pick a behaviour class and use it as a factory, like we did with ''Person'' and ''PersistablePerson'', we could just as easily have used ''PersonFactory'' and ''PersistablePersonFactory''.
So why should we bother doing the extra work it means to inherit from the factory?
The reason is that we want to express the concept "person" and improve the readability:
 <source>
    Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
 </source>
...even though ''Person'' is just one behaviour representation among others it's a natural representative of the concept "person" and a good candidate for the factory role.


If you don't want a behaviour representation act as a factory you have to inherit from either (e.g.) ''PersonValue'' or ''PersonEntity'':
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonEntity;
import com.myproject.state.PersonState;

public class PersistablePerson extends PersonEntity {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // ...
}
</source>


If the state template definition (''PersonStateTemplate'' in this case) includes a ''natural key'' (keyword "(key)") both the ''value'' and the ''entity'' class is generated,
otherwise only the ''value'' class is generated. If you remove the ''natural key'' from e.g. ''PersonStateTemplate'' you need to manually remove ''PersonEntity'' and all related ''PersonEntityFactory'' classes.
This will be improved in a future version!


When a state template, e.g. ''PersonStateTemplate'', is created and regenerated for the first time, a couple of other classes is also generated.
The class ''Person'' is generated and put under the (non-generated) ''java'' directory structure and ''PersonFactory'' is generated and put under the ''java-gen'' structure. If we don't need the behaviour representation ''Person'' we can just delete or rename it.

<span id="create_factory_in_two_steps"></span>
=== Put the factory in the specialized representation ===

If we add a new representation, we can let this act as factory instead of ''Person''. If we do that, it need to be created in two steps by first inherit from ''PersonValue'':
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class XmlPerson extends PersonValue {
    public XmlPerson(PersonState state) {
        super(state);
    }

    // (factory)
    public XmlPerson asXmlPerson() {
        return new XmlPerson(state);
    }
}
</source>

...regenerate and then inherit from (the newly created) ''XmlPersonFactory'':
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class XmlPerson extends XmlPersonFactory {
    public XmlPerson(PersonState state) {
        super(state);
    }

    // (factory)
    public XmlPerson asXmlPerson() {
        return new XmlPerson(state);
    }
}
</source>

An instance of ''XmlPerson'' is then created by e.g.:
<source>
    XmlPerson xmlPerson = XmlPerson.givenName("Eric").surname("Adams").asXmlPerson();
</source>


[[Behaviour|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[Populate state|Next >]]
