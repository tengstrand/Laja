In our examples we have used ''Person'' as factory when creating instances of ''Person''. We could also have used the generated class ''PersonFactory'':
<source>
    Person person1 = PersonFactory.givenName("Ingmar").surname("Bergman").asPerson();
    Person person2 = PersonFactory.build().withGivenName("Ingmar").withSurname("Bergman").asPerson();
</source>

To make ''Person'' a factory we let it inherit from ''PersonFactory'':
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</source>

Only the method that is marked as ''factory'' can be directly created by the factory class. If an "as-method" is not marked as factory then it has to be called via the factory method:
<source>
PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPerson().asPersistable();
</source>

If we also mark ''asPersistable'' as factory:
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</source>

...we can create instances directly:
<source>
PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPersistable();
</source>


In some situations we want the object themselves to act as factory:
<source>
Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
PersistablePerson persistablePerson = PersistablePerson.givenName("Ingmar").surname("Bergman").asPersistable();
</source>

...this is accomplished by letting the behaviour class inherit from the corresponding factory class and include a factory method.
Note that ''PersistablePerson'' need to be generated in two steps by first inheriting from ''PersonFactory'':

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // Behaviour is added here...
}
</source>

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class PersistablePerson extends PersonFactory {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    // Behaviour is added here...
}
</source>

...regenerate to create the class ''PersistablePersonFactory'' and inherit from it:

<source>
...
public class PersistablePerson extends PersistablePersonFactory {
...
</source>


It's not mandatory to pick a behaviour class and use it as a factory, like we did with ''Person'' and ''PersistablePerson'', we could just as easily have used ''PersonFactory'' and ''PersistablePersonFactory''.
So why should we bother doing the extra work it means to inherit from the factory?
The reason is that we want to express the concept "person" and improve the readability of the code:
<source>
Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
</source>
...even though ''Person'' is just a behaviour representation among others it's a natural representative of the concept "person" and a good candidate for the factory role.


If you don't want a behaviour representation act as factory you have to inherit from either ''PersonValue'' or ''PersonEntity'' (if it is a "person"!):
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonEntity;
import com.myproject.state.PersonState;

public class PersistablePerson extends PersonEntity {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // ...
}
</source>

If the state template definition (''PersonStateTemplate'' in this case) includes a ''natural key'', both the ''value'' and the ''entity'' class is generated,
otherwise only the ''value'' class is generated.


If we add a new state template, e.g. ''AddressStateTemplate.java'', and regenerate, the behaviour class ''Address'' will also be generated (if not exists) an put in the same package as the state template under the ''java'' directory structure.
This is the only situation where generated code is put somewhere else than in the ''outDir'' directory.
''Address'' is generated to give you a flying start with creating behavior representations for the concept "address".
If you don't want the generated class ''Address'' you can rename and/or move it to another package.
At the moment CDD requires at least one behaviour representation per state and if it can't find any, it will generate one for you!


[[Behaviour|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[Populate state|Next >]]
