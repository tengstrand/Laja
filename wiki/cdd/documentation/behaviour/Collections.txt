One of the main goals of CDD is to facilitate work in different contexts, and collections are no exception from this goal.
The targeting language is Java and because the whole Java echo system is build around mutable state using
[http://en.wikipedia.org/wiki/Mutator_method getters and setters] and mutable collections, the decision was taken to
let mutable state be the default in this implementation of CDD.
Only lists are supported in this alpha version but support for sets and maps along with mechanisms preventing state
to be simultaneously modified from different contexts will be added in a later version.


When a new behaviour class is created, like ''Person'', a corresponding behaviour list interface ''PersonList'' and a concrete class ''PersonArrayList''
are created when the code is generated next time.

Let's add a state template for "person" (of modify the existing) to demonstrate this:

<source>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
}
</source>

...regenerate and the class ''Person'' in source directory ''java'' should now look like this (if it was generated for the first time):

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }
}
</source>

...and a list interface in directory ''java-gen'' was also created:

<source>
package net.sf.laja.example.person.behaviour;

import java.util.List;

public interface PersonList extends List<Person> {
}
</source>

...and a list class in directory ''java-gen'':

<source>
public class PersonArrayList implements PersonList, RandomAccess, Cloneable, java.io.Serializable {
    protected PersonStateList stateList;
    protected final List<Person> list;

    ...a lot of code goes here...
}
</source>

An instance of ''PersonArrayList'' can now be created in this way:
<source>
PersonList persons = Person.createList(
        Person.givenName("Anders").surname("Andersson"),
        Person.givenName("Carl").surname("Carlsson")).asPersonList();

System.out.println(persons);
</source>

...output:
<source>
PersonArrayList{[Person{givenName='Anders', surname='Andersson'}, Person{givenName='Carl', surname='Carlsson'}]}
</source>

=== A new context ===
__NOTOC__

Let's say we need to implement functionality that export persons to a file in a semicolon separated text format.

This is a ''new context'' so let's create the class ''PersonRowInFile''
(we don't want to mix responsibilities by adding this functionality to ''Person''):
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class PersonRowInFile extends PersonFactory {
    public PersonRowInFile(PersonState state) {
        super(state);
    }

    public String getText() {
        return state.getGivenName() + ";" + state.getSurname() + ";";
    }
}
</source>

...add the switcher method ''asPersonRowInFile'' to ''Person'' and regenerate to create the corresponding list classes ''PersonRowInFileList'' and ''PersonRowInFileArrayList'':
<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // (factory)
    public PersonRowInFile asPersonRowInFile() {
        return new PersonRowInFile(state);
    }
}
</source>

...create the class ''PersonExporter'':
<source>
package com.myproject.behaviour;

public class PersonExporter {

    public void export(PersonRowInFileList persons) {
        System.out.println("Start exporting");

        for (PersonRowInFile person : persons) {
            System.out.println("  Exported: " + person);
        }
        System.out.println("End");
    }
}
</source>

...verify the exporter:
<source>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        PersonExporter exporter = new PersonExporter();

        PersonRowInFileList persons = Person.createList(
                Person.givenName("Anders").surname("Andersson"),
                Person.givenName("Carl").surname("Carlsson")
        ).asPersonRowInFileList();

        exporter.export(persons);
    }
}
</source>

...output:
<source>
Start exporting
  Exported: PersonRowInFile{givenName='Anders', surname='Andersson'}
  Exported: PersonRowInFile{givenName='Carl', surname='Carlsson'}
End
</source>

The code seemed to work as expected!

=== Switching context ===

A convenient thing with the behaviour lists is that they contain all the corresponding switcher methods from the value/entity class.

If we have a switcher method in ''Person'' (even if it's not a factory):
<source>
    public PersonRowInFile asPersonRowInFile() {
        return new PersonRowInFile(state);
    }
</source>

...we also get a corresponding switcher method in ''PersonList'':
<source>
public interface PersonList extends List<Person> {
    TextPersonList asTextPersonList();
}
</source>

...which allows us to write:

<source>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        PersonExporter exporter = new PersonExporter();

        // 1. Create a list of Person elements.
        PersonList persons = Person.createList(
                Person.givenName("Anders").surname("Andersson"),
                Person.givenName("Carl").surname("Carlsson")
        ).asPersonList();

        // 2. Context switch to a list of PersonRowInFile elements.
        exporter.export(persons.asPersonRowInFileList());
    }
}
</source>

=== Creating lists ===

We have already seen that a list can be created like this:
<source>
PersonList persons = Person.createList(
        Person.givenName("Anders").surname("Andersson"),
        Person.givenName("Carl").surname("Carlsson")).asPersonList();
</source>

...or an empty list like this:
<source>
PersonList persons = Person.createList();
</source>

A list can aso be created by instantiating ''PersonArrayList'' via one of its constructors:

<source>
public PersonArrayList(Person... list) { ... }
public PersonArrayList(Collection<Person> list) { ... }
public PersonArrayList(PersonStateList stateList) { ... }
</source>

...which allows us to create a list like this (using the first constructor):
<source>
Person person = Person.givenName("Carl").surname("Carlsson").asPerson();
PersonList persons = new PersonArrayList(person);
</source>

...or for example like this (using the second constructor):
<source>
Person person = Person.givenName("Carl").surname("Carlsson").asPerson();

Set<Person> set = new HashSet<Person>();
set.add(person);

PersonList persons = new PersonArrayList(set);
</source>

The last constructor:
<source>
public PersonArrayList(PersonStateList stateList) { ... }
</source>

...can only be called if we have access to the state and that should only be the case if we are inside a behaviour object!
The state should never be exposed outside behaviour representations in CDD because that would break the encapsulation!
Let's see how the exporter could look like if we use composition, start by creating a state template:

<source>
package com.myproject.state;

public class ExporterStateTemplate {
    PersonStateList persons;
}
</source>

...regenerate and modify the newly created ''Exporter'' (the third constructor is called in the ''Exporter''s constructor):

<source>
package com.myproject.behaviour;

import com.myproject.state.ExporterState;

public class Exporter extends ExporterFactory {
    private final TextPersonList persons;

    public Exporter(ExporterState state) {
        super(state);
        persons = new TextPersonArrayList(state.getPersons());
    }

    // (factory)
    public Exporter asExporter() {
        return new Exporter(state);
    }

    public void export() {
        System.out.println("Start exporting");

        for (TextPerson person : persons) {
            System.out.println("  Exported: " + person);
        }
        System.out.println("End");
    }
}
</source>

...if executing:

<source>
Exporter.persons(
        Person.givenName("Anders").surname("Andersson"),
        Person.givenName("Carl").surname("Carlsson")
).asExporter().export();
</source>

...we get the output:

<source>
Start exporting
  Exported: TextPerson{givenName='Anders', surname='Andersson'}
  Exported: TextPerson{givenName='Carl', surname='Carlsson'}
End
</source>

All collection state members are initialized to empty lists and are ready to be used:

<source>
public class ExporterStateImpl implements ExporterState {
    protected PersonStateList persons;
    ...
    ExporterStateImpl() {
        persons = PersonStateListImpl.emptyList();
    }
    ...
}
</source>

=== Dynamic context ===

If you follow the instructions in the [[Dynamic context|dynamic context]] section by adding ''UserRole'', ''PersonStateTemplate'',
''PersonAdmin'' and ''PersonRestricted'' and generate, then you will be able to create instances of person:

<source>
Person admin = PersonFactory.name("Anders").phoneNumber("011-11111111").asPerson(UserRole.ADMIN);
</source>

...where 'Person' is an interface and the concrete classes is hidden behind a factory.
The same technique can also be used for lists:

<source>
PersonList persons = PersonFactory.createList(
        PersonFactory.name("Anders").phoneNumber("011-11111111"),
        PersonFactory.name("Richard").phoneNumber("022-22222222")
).asPersonList(UserRole.ADMIN);

System.out.println(persons);
</source>

...output:

<source>
PersonArrayList{[PersonAdmin{name='Anders', phoneNumber='011-11111111'}, PersonAdmin{name='Richard', phoneNumber='022-22222222'}]}
</source>

=== Caution ===

CDD is still in an alpha version and some functionality is still missing and more work needs to be done especially with the collections.


If creating a list by sending in a ''state list'' in the constructor like we did in the ''Exporter'':

<source>
persons = new TextPersonArrayList(state.getPersons());
</source>

...CDD will ensure that the behaviour list ''persons'' and the underlying ''state list'' (state.persons) is always in sync if mutating ''persons''.
This can be a problem if you have more than one behaviour representation of "person list".
If you expose the internal list ''persons'' by adding a getter and the list is used outside the aggregate via that getter
and context switched into another list that is sorted (or mutated in some way),
the ''state list'' will also be sorted to keep them in sync but leaves ''persons'' and the ''state list'' out of sync.
There is no functionality at the moment that automatically synchronizes behaviour lists when they fall out of sync with the state list.

The other three ways a list can be created does not have this problem since they are not connected to a ''state list''.

=== Summary ===

Collections in CDD is rather dumb.
The way we add behaviour to them is by using composition, like we did with the ''Exporter'', which leads us to the next exciting area, [[Composition|composition]]!


[[Populate substate|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[Composition|Next >]]
