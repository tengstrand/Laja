Encapsulation is essentially about hiding state and defining behaviour from the perspective of state.

This can be illustrated by an example. Assume ''PersonState'' has the attribute ''age''.
Now the behaviour "is middle age" can be defined from the perspective of "age":

<source>
public class Person ... {
    ...

    public boolean isMiddleAge() {
        return state.getAge() >= 40 && state.getAge() <= 55;
    }
}
</source>

The class ''Person'' only expose ''behaviour'' in its public API, via the method ''isMiddleAge'', and hides its
inner representation held by ''state''. The ''state'' instance should never be exposed outside the object itself.

A good thing is that we can change how ''age'' is represented without changing the public API.
Even more important is that we have the definition of "is middle age" in one place with the descriptive name ''isMiddleAge'',
which keeps the code [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself DRY].

All ''behavior'' is in one way or another related to some ''state'', either directly or indirectly, where
state can be defined as "data at a given time".


Let's explore how encapsulation is handled in this implementation of CDD, start by adding:

<source>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String name;
}
</source>

... if we regenerate and write:

<source>
Person person = Person.age(18).name("Gordon").asPerson();
</source>

...then an instance of ''Person'' is created. The state is first built by "Person.age(18).name("Gordon")"
followed by encapsulation performed by "asPerson()", all in one statement. We could also have written:

<source>
PersonEncapsulator encapsulator = Person.age(18).name("Gordon");
Person person = encapsulator.asPerson();
</source>

...which allows us to validate the state:

<source>
PersonEncapsulator encapsulator = Person.age(18).name(null);
System.out.println("Is valid: " + encapsulator.isValid());
Person person = encapsulator.asPerson();
</source>

...if executed we get:

<source>
Is valid: false
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
	at com.myproject.behaviour.PersonValueFactory$PersonFactory_.create(PersonValueFactory.java:43)
	at com.myproject.state.PersonStateBuilderImpl.as(PersonStateBuilderImpl.java:46)
	at com.myproject.behaviour.PersonEncapsulator.asPerson(PersonEncapsulator.java:14)
	at com.myproject.behaviour.Main.main(Main.java:7)
	...
</source>

The instance of ''Person'' could not be created due to the mandatory attribute ''name'' was not set.
CDD prevents encapsulation of invalid state but offers an opportunity to validate state before encapsulation takes place.
This allows us to take appropriate actions if the state would prove to be wrong.


We could apply this pattern when building a repository, start by modifying ''Person'':

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // (factory)
    public PersonMatcher asPersonMatcher() {
        return new PersonMatcher(state);
    }

    public boolean isMiddleAge() {
        return state.getAge() >= 40 && state.getAge() <= 55;
    }
}
</source>

...add ''PersonMatcher'', ''PersonRepository'' and ''Main'':

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class PersonMatcher extends PersonFactory {
    public PersonMatcher(PersonState state) {
        super(state);
    }

    public boolean isNameContaining(String searchFor) {
        return state.getName().contains(searchFor);
    }
}
</source>

<source>
package com.myproject.behaviour;

public class PersonRepository {
    private PersonListEncapsulator encapsulators = Person.createList(
            Person.age(20).name("Anders"),
            Person.age(30).name("Bert"),
            Person.age(40).name("Cecilia"),
            Person.age(50).name("David"),
            Person.age(60).name("Eric")
    );

    public PersonListEncapsulator findByName(String searchFor) {
        PersonListEncapsulator result = Person.createList();

        for (PersonEncapsulator encapsulator : encapsulators) {
            if (encapsulator.asPersonMatcher().isNameContaining(searchFor)) {
                result.add(encapsulator);
            }
        }
        return result;
    }
}
</source>

<source>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        PersonRepository repository = new PersonRepository();

        System.out.println("Is valid: " + repository.findByName("c").isValid());
        System.out.println("Result: " + repository.findByName("c").asPersonList());
    }
}
</source>

...if executing ''Main'' we get:

<source>
Is valid: true
Result: PersonArrayList{[Person{age=40, name='Cecilia'}, Person{age=60, name='Eric'}]}
</source>


[[Classes and objects|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[Context|Next >]]
