So far we have used ''chained creators'' to build state.
In situations when you don't have control of in which order the attributes are going to be set, a ''builder'' can be more convenient.


Let's start with an example:
<source>
PersonCreator.buildPerson().asPerson();
</source>

It's normally a good idea to cleanup the code with a static import:
<source>
import static com.myproject.PersonCreator.buildPerson;
</source>

...so that we can write:
<source>
buildPerson().asPerson();
</source>

output:
<source>
Exception in thread "main" com.myproject.PersonState$InvalidPersonStateException: [ValidationError{attribute='ssn', errorType='NULL', errorMessage='Attribute 'ssn' can not be NULL'}, ValidationError{attribute='givenName', errorType='NULL', errorMessage='Attribute 'givenName' can not be NULL'}]
	at com.myproject.PersonState$PersonMutableState.assertIsValid(PersonState.java:244)
	at com.myproject.PersonState$PersonMutableState.asImmutable(PersonState.java:184)
	at com.myproject.PersonCreator$PersonBuilder.asState(PersonCreator.java:266)
	at com.myproject.Main.main(Main.java:9)
    ...
</source>

The state could not be encapsulated because the mandatory attributes ''ssn'' and ''givenName'' was not set.
A ''chained creator'' force you to set all mandatory attributes but that is not the case with builders
and is the reason why chained creators is the preferable choice in most situations.


The next example shows how a builder can be used:

<source>
PersonBuilder builder = buildPerson();

builder.withSsn(123); // Set one attribute at a time...
builder.withGivenName("Ingmar").withSurname("Bergman"); // ...or use method chaining.

System.out.println(builder.asState());
</source>

output:
<source>
{ssn=123, givenName="Ingmar", surname="Bergman"}
</source>


[[Default values|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[State validation|Next >]]
