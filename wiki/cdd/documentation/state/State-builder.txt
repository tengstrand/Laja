So far we have used ''chained creators'' to build state.
In situations when you don't have control of in which order the attributes are going to be set, a ''builder'' can be more convenient.


Let's start with an example:
<source>
Person person = Person.build().asPerson();
</source>

output:
<source>
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
	at com.myproject.behaviour.PersonEntityFactory$PersonFactory_.create(PersonEntityFactory.java:35)
	at com.myproject.state.PersonStateBuilderImpl.as(PersonStateBuilderImpl.java:51)
	at com.myproject.behaviour.PersonBuilder.asPerson(PersonBuilder.java:37)
	at com.myproject.behaviour.Main.main(Main.java:5)
	...
</source>

The state could not be encapsulated because the mandatory attributes ''ssn'' and ''givenName'' was not set.
A ''chained creator'' force you to set all mandatory attributes but that is not the case with builders
and is the reason why chained creators is the preferable choice in most situations.


The next example shows how a builder can be used:

<source>
PersonBuilder builder = Person.build();

builder.withSsn(123); // Set one attribute at a time...
builder.withGivenName("Ingmar").withSurname("Bergman"); // ...or use method chaining.

Person person = builder.asPerson(); // Once encapsulated...
System.out.println(person);

builder.withSsn(222); //... the state can not be mutated by the builder.
</source>
output:
<source>
Person{ssn=11111, givenName='Ingmar', surname='Bergman'}
Exception in thread "main" java.lang.IllegalStateException: The state can only be mutated by current instance of com.myproject.behaviour.Person
...
</source>

Once encapsulated, the state can not be changed by the builder as shown by this example.


[[Default values|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[State validation|Next >]]
