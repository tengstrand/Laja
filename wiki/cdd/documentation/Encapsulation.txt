__NOTOC__
Encapsulation is essentially about hiding state behind behaviour.

This can be illustrated by an example. Assume ''PersonState'' has the attribute ''age''.
Now the behaviour "is teenager" can be defined from the perspective of ''age'':

<source>
public class Person ... {
    ...

    public boolean isTeenager() {
        return state.getAge() >= 13 && state.getAge() <= 19;
    }
}
</source>

The class ''Person'' only exposes ''behaviour'' in its public API, via the method ''isTeenager'', and hides the
inner representation held by ''state''. The ''state'' instance should never be exposed outside the object itself
(except from within other person representations) which otherwise would break encapsulation.

A good thing about this approach to encapsulation is that we can change how ''age'' is represented without changing the public API.
Even more important is that we have a single definition of "is teenager" with the descriptive name ''isTeenager''
which helps us keep the code [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself DRY] and easier to understand and maintain.

All ''behavior'' that is not constant is in one way or another related to some ''state'', either directly or indirectly.

=== The problem ===

In traditional OO, you can create a class with clear encapsulated responsibility, but the problem begins when you need to work with that class in a different context.
Lets say we create the class ''Person'' only containing methods related to the core domain. When you want to export an instance of ''Person'' as a text format, you are facing two bad alternatives:
* Add the method ''toText()'' to ''Person'' (which converts the state to a text row to be used by the exporter) resulting in braking the [http://en.wikipedia.org/wiki/Single_responsibility_principle single responsibility principle].
* Add some getters to ''Person'' and delegate the work to e.g. ''PersonTextExporter'' leading to broken encapsulation and violation of the [http://c2.com/cgi/wiki?TellDontAsk Tell Don't Ask] principle (which is about letting objects perform their own tasks).

The good news is that you don't need to make either of these two compromises in CDD!

=== The solution ===

Let's explore how encapsulation is handled with CDD, start by adding a state definition:

<source>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String name;
    String hobby; // (optional)
}
</source>

... if we generate and write:

<source>
Person person = Person.age(18).name("Thomas").asPerson();
</source>

...then an instance of ''Person'' is created. The state is first built by the [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator]
"Person.age(18).name("Thomas")" followed by encapsulation performed by "asPerson()", all in one statement.
We could also have divided it into two statements (''PersonEncapsulator'' is code generated):

<source>
PersonEncapsulator encapsulator = Person.age(18).name("Thomas");
Person person = encapsulator.asPerson();
</source>

...which allows us to validate the state:

<source>
PersonEncapsulator encapsulator = Person.age(18).name(null);
System.out.println("Is valid: " + encapsulator.isValid());
Person person = encapsulator.asPerson();
</source>

...if executed we get:

<source>
Is valid: false
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
	at com.myproject.behaviour.PersonValueFactory$PersonFactory_.create(PersonValueFactory.java:43)
	at com.myproject.state.PersonStateBuilderImpl.as(PersonStateBuilderImpl.java:46)
	at com.myproject.behaviour.PersonEncapsulator.asPerson(PersonEncapsulator.java:14)
	at com.myproject.behaviour.Main.main(Main.java:7)
	...
</source>

The instance of ''Person'' could not be created due to the mandatory attribute ''name'' was not set.
CDD prevents encapsulation of invalid state but offers an opportunity to validate state before encapsulation takes place.
This allows us to take appropriate actions if the state would prove to be wrong.

=== Mutating state after encapsulation ===

Once encapsulated, the state can not be mutated by the encapsulator:
<source>
PersonEncapsulator encapsulator = Person.age(18).name("Thomas");
System.out.println("Is valid: " + encapsulator.isValid());
Person person = encapsulator.asPerson();

encapsulator.withHobby("Collecting stamps"); // Trying to mutate the state
</source>

...output:
<source>
Is valid: true
Exception in thread "main" java.lang.IllegalStateException: The state can only be mutated by current instance of com.myproject.behaviour.Person
	...
</source>

=== Working in one context at a time ===

It's only possible to mutate state from one context at a time. Let's illustrate this by adding some code:

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class NicePerson extends PersonValue {
    public NicePerson(PersonState state) {
        super(state);
    }
}
</source>

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public NicePerson asNicePerson() {
        return new NicePerson(state);
    }

    public void mutate() {
        state.setAge(1, this); // Always send in the mutator which is 'this'.
    }
}
</source>

...if executing:
<source>
Person person = Person.age(18).name("Thomas").asPerson();
person.mutate(); // OK to mutate state

NicePerson nicePerson = person.asNicePerson(); // Switch context to 'nice person'.

person.mutate(); // Only possible to mutate state from the context 'nice person'.
</source>

...we get:
<source>
Exception in thread "main" java.lang.IllegalStateException: The state can only be mutated by current instance of com.myproject.behaviour.NicePerson
	...
</source>

If we switch back context to ''person'' then it's possible to mutate state again:
<source>
Person person = Person.age(18).name("Thomas").asPerson();
person.mutate();

NicePerson nicePerson = person.asNicePerson();

person = person.asPerson(); // Switching the context back to 'person'
person.mutate(); // OK to mutate state
</source>


[[Classes and objects|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[Context|Next >]]
