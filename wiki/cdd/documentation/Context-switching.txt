The concept context switching as known here was invented in 2011 and first described [http://natureofcode.blogspot.se/2011/08/exploring-nature-of-code.html here].
It is now part of CDD and improved so that state and behavior are completely separated.


In an earlier example we switched context to be able to perform the save operation:
<source>
person.asPersistable().save();
</source>

The switching was performed by the method ''asPersistable()'':

<source>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</source>

Being able to switch context is not just a way to embrace [http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29 encapsulation] and the principles [http://c2.com/cgi/wiki?TellDontAsk Tell Don't Ask] and [http://en.wikipedia.org/wiki/Single_responsibility_principle Single responsibility],
it's also a way to reduce the amount of code needed to integrate different parts of the system.


Context switching can both mean switching task ''within'' an architectural layer as well as moving ''between'' architectural layers:


[[File:CDD-context-switching.png|400px]]


Example of architectural layers can be "GUI", "Domain" or "Persistence".
Example of different contexts within an architectural layer can be "Export as XML" or "Convert to format Y".

Context switching is a key concept of CDD which allows our objects to travel around the system, performing well defined tasks, almost friction free.
We don't need to convert between different state representations when crossing context borders because the state format never change.
Conversion between state representations are a common source of errors that is almost eliminated in CDD.
Support for packing and unpacking state so that objects can cross physical context borders is not included in this alpha version but may be added in a later version.

=== Layers and tier of deployment ===
It's often a good thing to separate different responsibilities into different logical layers in the codebase (packages/modules).
If we do that it will affects the design of the system in a positive direction so that modularity and cohesion is increased.
There is a common misconception that architectural layers are the same as tiers of deployment. This is well described in this [http://gojko.net/2010/06/11/udi-dahan-the-biggest-mistakes-teams-make-when-applying-ddd blog post] by Udi Dahan and the same principles is also applicable to CDD.
Assume that you own and have control over all source code in your layered system.
If the layers are physically separated (deployed to different physical locations) and a layer (for example the ''GUI'') need access to another layer (for example the ''Domain'')
then the ''domain code'' (in this example) should also be deployed to the ''GUI'' tier.


But is not this an example of mixing of responsibility? The answer i no, we only ''use'' the "core domain" business rules from the GUI layer, we don't add or duplicate the business rules.
It's very similar to calling a service with the difference that instead of sending the state to a service and letting the service operate on it,
we ''encapsulate'' the state so that we can work in a more object oriented way. For example ''person.save()'' instead of ''service.save(person)''.
The latter breaks encapsulation (if not using techniques like reflection) which may lead to a situation where business rules are scattered around the system instead of gathered into one place.

The rule of thumb is that different parts of the codebase should be maintained in ''one place'' but is allowed to be deployed and used from ''several places''.
This helps to keep the code clean and [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself DRY].


[[Behaviour|< Back]]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[[Factories|Next >]]