== Introduction ==

Context Driven Development (CDD) takes a new approach to object orientation by separating ''state'' and ''behaviour''.
That allows us to work in different context without breaking encapsulation.
It's also the foundation that makes it possible to improve the way state is built and validated.
The problem is solved by using ''code generation''.
By using code generation, the amount of code you need to write is reduced to a minimum which allows us to
focus more on ''what'' to do instead of ''how'' resulting in cleaner and more concise code.

== Basic concepts ==
If we take a look at the [[CDD_-_Getting_started|Getting started]] example, it has the following structure in the IDE:

[[File:project-directory-structure.png]]

The directory ''java-gen'' contains a lot of code generated classes, but don't worry (be happy!) they are here to make your development experience more pleasant!

If you are using a version control system you should put both ''java'' and ''java-gen'' under version control.


Let's explain some of the basic concepts of CDD by looking at three of the four classes: ''PersonStateTemplate'', ''Person'' and ''Main'':

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String givenName;
    String surname;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    public boolean isAdult() {
        return state.getAge() >= 18;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {

    public static void main(String[] args) {
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
        System.out.println("Is adult: " + person.isAdult());

        person.asPersistable().save();
    }
}
</pre>

output:
<pre>
Is adult: false
The state was saved: {age=15, givenName='Ingmar', surname='Bergman'}
</pre>


Let's take a closer look at the statement that creates an instance of ''Person'' (in the ''Main'' class):
<pre>
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
</pre>

In CDD you start by building state and ends with choosing a behaviour representation (encapsulation).
In this example all attributes are mandatory and therefore included in the [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator]: ''age(15).givenName("Ingmar").surname("Bergman")''.
The attributes are defined in ''PersonStateTemplate'', and the chained creator, the toString method (shown in the output) and others are based on this definition.

== The problem CDD solves ==

The statement...
<pre>
        person.asPersistable().save();
</pre>

...switches context and saves the instance.


If our code would have been written in a more traditional object oriented style, we would have to choose between two bad alternatives (pretend that we can't use a bytecode instrumenting persistence framework here!):
# Add the method ''save'' to ''Person''.
# Add some getters to ''Person'' and let another class perform the ''save'' operation.

The first alternative leads to unclear responsibility with reduced [http://en.wikipedia.org/wiki/Cohesion_%28computer_science%29 cohesion] as a result.
It's usually preferable to let a class ''work in one context'' by following the [http://en.wikipedia.org/wiki/Single_responsibility_principle single responsibility principle].

The second alternative breaks encapsulation by adding getters, which is bad and well described [http://typicalprogrammer.com/?p=23 here].


A problem with traditional OO is that you have to choose between ''mixing responsibilities'' and ''breaking encapsulation'', the CDD you do neither of them!

== Manage state ==
The decision to separate ''state'' and ''behavior'' enables us to improve the objects creation process.

Instead of creating objects in one step by using a constructor, the object is created in several steps giving a number of advantages:
* The state is defined in a [http://en.wikipedia.org/wiki/Declarative_programming declarative] way so that ''equals'', ''hashCode'' and ''toString'' can be generated, letting you focus on the properties of each attribute.
* The [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator] and/or [http://en.wikipedia.org/wiki/Builder_pattern builder pattern] is used to build state which is more robust and flexible than a set of constructors (or even worse, an empty constructor with a bunch of setters!)
* Ensures valid state before encapsulation takes place.
* The state can be validated before encapsulation takes place, which is handy when working with external data sources and user input.
* The encapsulation step can be postponed allowing the calling code to perform validation and encapsulation.

== Define state ==
The states is defined in ''state templates'' and is expected to be found in directory ''srcDir'', package ''statePackate'' in the project file, e.g. ''myproject.laja'':
<pre>
#generateCdd([{
  srcDir: "{.}/main"
  outDir: "{..}/java-gen/main"
  statePackage: "com.myproject.state"
  behaviourPackage: "com.myproject.behaviour" }]
)
</pre>

Example of valid state packages (in this example) are:
* com.myproject.state
* com.myproject.state.domain
* com.myproject.state.infrastructure.x''


The instruction ''#generateCdd'' is just an ordinary [[Code_generator_-_System_functions|Laja system function]] that is parsed and executed by Laja.


A ''state template'' is an ordinary Java class, e.g.:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int personId; // (id)
    long socialSecurityNumber; // (key)
    String givenName;
    String middleName; // (optional)
    String surname;
    String specialInfo; // (exclude)
}
</pre>

Each attribute (''personId, socialSecurityNumber, givenName...) can have one or several properties by ending the line with a comment. None of them are mandatory:

{| class="wikitable"
! Keyword !! Example !! Description
|-
|
id
||
<span style="color:#008000">int</span>&nbsp;personId;&nbsp;// (id)
||
The [http://en.wikipedia.org/wiki/Surrogate_key surrogate key]. Only one attribute can be marked as surrogate key.
|-
|
key
||
<span style="color:#008000">long</span>&nbsp;socialSecurityNumber;&nbsp;//&nbsp;(key)
||
The [http://en.wikipedia.org/wiki/Natural_key natural key]. One or several attributes can be included in the natural key.
|-
|
optional
||
<span style="color:#008000">String</span>&nbsp;middleName;&nbsp;//&nbsp;(optional)
||
When an attribute is marked as ''optional'' it will be excluded from the ''chained creator'' and is allowed to be null.
|-
|
(hide)
||
int length; // (hide)
||
When an attribute is marked as ''hide'' it is still mandatory (if not also marked as ''optional'') but excluded from the ''chained creator''.
The attribute is expected to be set by the ''behaviour'' constructor.
|-
|
(exclude)
||
int Exclude...
||
Exclude...
|-
|
(stateless)
||
Stateless
||
Stateless
|}
