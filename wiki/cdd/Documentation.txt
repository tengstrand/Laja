== Introduction ==

Context Driven Development (CDD) takes a new approach to object orientation by separating ''state'' and ''behaviour''.
That allows us to work in different context without breaking encapsulation.
It's also the foundation that makes it possible to improve the way state is built and validated.
The problem is solved by using ''code generation''.
By using code generation, the amount of code needed to be written is reduced to a minimum which allows us to
focus more on ''what'' to do instead of ''how'' resulting in cleaner and more concise code.

== Basic concepts ==
If we take a look at the [[CDD_-_Getting_started|Getting started]] example, it has the following structure in the IDE:

[[File:project-directory-structure.png]]

The directory ''java-gen'' contains a lot of code generated classes, but don't worry (be happy!) they are here to make your development experience more pleasant!

If you are using a version control system you should put both ''java'' and ''java-gen'' under version control.


Let's explain some of the basic concepts of CDD by looking at three of the four classes from the Getting started example: ''PersonStateTemplate'', ''Person'' and ''Main'':

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String givenName;
    String surname;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    public boolean isAdult() {
        return state.getAge() >= 18;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {

    public static void main(String[] args) {
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
        System.out.println("Is adult: " + person.isAdult());

        person.asPersistable().save();
    }
}
</pre>

output:
<pre>
Is adult: false
The state was saved: {age=15, givenName='Ingmar', surname='Bergman'}
</pre>


Let's take a closer look at the statement that creates an instance of ''Person'' (in the ''Main'' class):
<pre>
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
</pre>

In CDD you start by building state and ends with choosing a behaviour representation (encapsulation).
In this example all attributes are mandatory and therefore included in the [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator]: ''age(15).givenName("Ingmar").surname("Bergman")''.
The attributes are defined in ''PersonStateTemplate''. The ''chained creator'', the ''toString'' method (shown in the output) and others are based on this definition.

The statement...
<pre>
        person.asPersistable().save();
</pre>

...switches context and saves the instance.


If our code would have been written in a more traditional object oriented style, we would have to choose between two bad alternatives (if we don't use a bytecode instrumenting persistence framework!):
# Add the method ''save'' to ''Person''.
# Add some getters to ''Person'' and let another class perform the ''save'' operation.

The first alternative leads to unclear responsibility with reduced [http://en.wikipedia.org/wiki/Cohesion_%28computer_science%29 cohesion] as a result.
It's usually preferable to let a class work in ''one context'' by following the [http://en.wikipedia.org/wiki/Single_responsibility_principle single responsibility principle].

The second alternative breaks encapsulation and the [http://c2.com/cgi/wiki?TellDontAsk Tell don't Ask] principle by adding getters. Why adding getters is bad is well described [http://typicalprogrammer.com/?p=23 here].


A problem with traditional OO is that you have to choose between ''mixing responsibilities'' and ''breaking encapsulation''.

CDD is tackling this problem letting you build representations that work in ''one context'' without breaking encapsulation!

== Manage state ==
The decision to separate ''state'' and ''behavior'' enables us to improve the objects creation process.

Instead of creating objects in one step by using a constructor, the object is created in several steps which gives us a number of advantages:
* The state is defined in a [http://en.wikipedia.org/wiki/Declarative_programming declarative] way so that ''equals'', ''hashCode'' and ''toString'' can be generated, letting you focus on the properties of each attribute.
* The [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator] and/or [http://en.wikipedia.org/wiki/Builder_pattern builder pattern] is used to build state which is more robust and flexible than a set of constructors (or even worse, an empty constructor with a bunch of [http://en.wikipedia.org/wiki/Mutator_method setters]!)
* Ensures valid state before encapsulation takes place.
* Ensures that the state can not be change from the outside once the encapsulation has taken place.
* The state can be validated before encapsulation takes place, which is handy when working with external data and user input.
* The encapsulation step can be postponed allowing delegation of validation and encapsulation to the caller.


The states is defined in ''state templates'' and is expected to be found in directory ''srcDir'', package ''statePackage'' in the project file, e.g. ''myproject.laja'':
<pre>
#generateCdd([{
  srcDir: "{.}/main"
  outDir: "{..}/java-gen/main"
  statePackage: "com.myproject.state"
  behaviourPackage: "com.myproject.behaviour" }]
)
</pre>

Example of valid state packages (in this example) are:
* com.myproject.state
* com.myproject.state.domain
* com.myproject.state.infrastructure.x''


Let's extend the state definition of "Person" by modifying the state template ''PersonStateTemplate'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int personId; // (id)
    int length; // (hide)
    long ssn; // (key)
    String givenName;
    String middleName; // (optional)
    String surname;
    String occupation; // (exclude)
}
</pre>

...regenerate and modify the main class:

<pre>
public class Main {
    public static void main(String[] args) {
        // The 'chained creator' starts here...
        Person person = Person.ssn(12345678).givenName("Ingmar").surname("Bergman")
                .withPersonId(1)                  // ...followed by builder methods
                .withMiddleName("Ernst")
                .withOccupation("Film director")
                .asPerson();                      // ...and encapsulation

        System.out.println(person);
    }
}
</pre>

...and modify the constructor of ''Person'' (setting the hidden attribute):
<pre>
    public Person(PersonState state) {
        super(state);
        state.setLength(179);
    }
</pre>

... gives the output:
<pre>
Person{personId=1, length=179, ssn=12345678, givenName='Ingmar', middleName='Ernst', surname='Bergman', occupation='Film director'}
</pre>


If we look at how the instance of ''Person'' is created in the ''Main'' class, it follows this pattern:
* Chained creator: contains all mandatory attributes using the pattern [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html Chained Creator].
* Builder methods: all optional attributes, marked as ''(optional)'', ''(id)'' or ''(exclude)''. These methods are not mandatory and can be omitted.
* Encapsulation: encapsulates the state by choosing a behaviour representation.


Each attribute can have one or several properties by ending the line with a comment. None of them are mandatory:

{| class="wikitable"
! Keyword !! Example !! Description
|-
|
(id)
||
<span style="color:#008000">int</span>&nbsp;personId;&nbsp;// (id)
||
The [http://en.wikipedia.org/wiki/Surrogate_key surrogate key]. Only one attribute can be marked as surrogate key.
|-
|
(key)
||
<span style="color:#008000">long</span>&nbsp;ssn;&nbsp;//&nbsp;(key)
||
The [http://en.wikipedia.org/wiki/Natural_key natural key]. One or several attributes can be included in the natural key.
|-
|
(optional)
||
<span style="color:#008000">String</span>&nbsp;middleName;&nbsp;//&nbsp;(optional)
||
The keywords ''(optional)'', ''(id)'' and ''(exclude)'' will exclude the attribute from the ''chained creator'' allowing them to be uninitialized (''null'').
|-
|
(hide)
||
<span style="color:#008000">int</span> length; // (hide)
||
The ''hide'' keyword excludes the attribute from the ''chained creator'' but requires it to be initialized (not ''null'') by the constructor of the ''behaviour'' class. If combined with ''(optional)'' the attribute will no longer be mandatory.
|-
|
(exclude)
||
<span style="color:#008000">String</span> occupation; // (exclude)
||
Same as ''optional'' except that it is excluded from ''hashCode()'' and ''equals()''.
|}


If all attributes are optional, then the chained creator can be accessed via the ''create()'' method, example:
<pre>
Person person = Person.create().withAge(16).asPerson();
</pre>

== Identity ==
A tricky part in object orientation is the management of ''identity''.
The problem in traditional OO has to do with the difficulties of switching context.

Take our class ''Person'' as an example, it has the attribute ''ssn'' marked as ''natural key'' (in ''PersonStateTemplate'') resulting in that only ''ssn'' is included in ''hashCode()'' and ''equals()'':
<pre>
public class PersonStateImpl implements PersonState {
    ...

    @Override
    public int hashCode() {
        int result = (int)ssn;

        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PersonStateImpl state = (PersonStateImpl)o;

        if (ssn != state.getSsn()) return false;

        return true;
    }

    ...
}
</pre>

This is the desired behaviour in most situations when working with a persistence layer.
In our test code, however, we may be interested in comparing (almost) all attributes in some situations.

In traditional OO we need to treat ''Person'' as either ''entity'' or ''value'' (database or test context in this example) while in CDD you can have both representations and switch between them!


Let's demonstrate how we can create the value based representation ''OtherPerson'' and switch context between the entity based ''Person'' and ''OtherPerson'', we start by creating the latter:
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class OtherPerson extends PersonValue {
    public OtherPerson(PersonState state) {
        super(state);
    }
}
</pre>

To make this class a ''value'' we extended from the generated class ''PersonValue'' with the following implementation of ''hashCode'' and ''equals'':
<pre>
    ...

    @Override
    public int hashCode() {
        return state.valueHashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;

        return state.valueEquals(((PersonValue)o).state);
    }

    ...
</pre>

...and the implementation of ''valueHashCode()'' and ''valueEquals()'' in ''PersonStateImpl'':
<pre>
    ...

    public int valueHashCode() {
        int result = length;
        result = 31 * result + (int)ssn;
        result = 31 * result + (givenName != null ? givenName.hashCode() : 0);
        result = 31 * result + (middleName != null ? middleName.hashCode() : 0);
        result = 31 * result + (surname != null ? surname.hashCode() : 0);

        return result;
    }

    public boolean valueEquals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PersonStateImpl state = (PersonStateImpl)o;

        if (length != state.getLength()) return false;
        if (ssn != state.getSsn()) return false;
        if (givenName != null ? !givenName.equals(state.givenName) : state.givenName != null) return false;
        if (middleName != null ? !middleName.equals(state.middleName) : state.middleName != null) return false;
        if (surname != null ? !surname.equals(state.surname) : state.surname != null) return false;

        return true;
    }

    ...
</pre>

If we add the following method to ''Person'':
<pre>
    public OtherPerson asOtherPerson() {
        return new OtherPerson(state);
    }
</pre>

.. and modify the ''main'' method in ''Main'':
<pre>
    public static void main(String[] args) {
        Person person1 = Person.ssn(111222).givenName("Ingmar").surname("Bergman").asPerson();
        Person person2 = Person.ssn(111222).givenName("Ingmar").surname("Johansson").asPerson();

        OtherPerson otherPerson1 = person1.asOtherPerson();
        OtherPerson otherPerson2 = person2.asOtherPerson();

        System.out.println("1. Equals: " + person1.equals(person2));
        System.out.println("2. Equals: " + otherPerson1.equals(otherPerson2));
    }
</pre>

..we get the output:
<pre>
1. Equals: true
2. Equals: false
</pre>

We can see that Person treats ''person1'' and ''person2'' as equal because they have the same value of ''ssn'' but treated as not equal when wrapped by ''OtherPerson'' because ''surname'' doesn't match.

== Composite state ==
CDD supports building composite states referred to as ''aggregate roots'' in [http://en.wikipedia.org/wiki/Domain-driven_design DDD].
Lets add the state definition "Address":
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;
}
</pre>

...regenerate and add it to the state definition of "Person":
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
    AddressState address;
}
</pre>

...regenerate and change ''Main'':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").surname("Bergman").address(
                Address.streetName("Main Street").streetNumber(123).zipcode(111222)).asPerson();

        System.out.println(person);
    }
}
</pre>

...gives the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Bergman', address={streetName='Main Street', streetNumber=123, zipcode=111222}}
</pre>

This example demonstrates how to build state of substates which can be very useful.

== Expanding substates ==
Substates can be "expanded" resulting in that the attributes of the substate is merged into the parent state. A dollar sign ($) marks a substate for expansion:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
    AddressState $address;
}
</pre>

...if we regenerate we can change ''Main'' to this:
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").surname("Bergman")
                .streetName("Main Street").streetNumber(123).zipcode(111222).asPerson();

        System.out.println(person);
    }
}
</pre>

...gives the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Bergman', streetName='Main Street', streetNumber=123, zipcode=111222}
</pre>

As we can see, the attributes from ''AddressState'' has been "exploded" and merged into ''PersonState''.
If we take a look at ''PersonState'' it now extends ''AddressState'':
<pre>
...

public interface PersonState extends AddressState {
    ...
}
</pre>

...this will make it possible to wrap both ''Person'' and ''Address'' behaviour around ''PersonState', more on that later.

If Laja finds two or more attributes with the same type and name they will be merged into a single attribute ''without any warnings''.
This is not how it should work and will be changed in the next release!

== Default values ==
Attributes can be set to default values, e.g:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname = "Unknown"; // (optional)
}
</pre>

...if regenerating and changing ''Main'':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").asPerson();

        System.out.println(person);
    }
}
</pre>

...we get the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Unknown'}
</pre>

== Build state ==
So far we have used ''chained creators'' to build state. Sometimes you need to build the states one piece at a time, in these situations you need a ''builder''. Example:
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.build()
                .withGivenName("Ingmar")
                .withSsn(11111)
                .withSurname("Bergman").asPerson();

        System.out.println(person);
    }
}
</pre>
output:
<pre>
Person{ssn=11111, givenName='Ingmar', surname='Bergman'}
</pre>

The attributes can occur in arbitrary order and some or all attributes can be left out:
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.build().asPerson();
    }
}
</pre>

output:
<pre>
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
	at com.myproject.behaviour.PersonEntityFactory$PersonFactory_.create(PersonEntityFactory.java:35)
	at com.myproject.state.PersonStateBuilderImpl.as(PersonStateBuilderImpl.java:51)
	at com.myproject.behaviour.PersonBuilder.asPerson(PersonBuilder.java:37)
	at com.myproject.behaviour.Main.main(Main.java:5)
	...
</pre>

As you can see, it's not possible to create instances if the state is invalid. In this case we have missed to set the mandatory attributes ''ssn' and ''givenName''.
With a ''builder'' you can't be sure that all mandatory attribute has been initialized and that is the main reason why a ''chained creator'' is the preferable choice in most situations.

== Validate state ==

The state can be validated before the state is encapsulated:

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        PersonEncapsulator personEncapsulator = Person.ssn(11111).givenName("Carl");
        PersonBuilder personBuilder = Person.build();

        System.out.println("1. Is valid: " + personEncapsulator.isValid());
        System.out.println("2. Is valid: " + personBuilder.isValid());
    }
}
</pre>

<pre>
1. Is valid: true
2. Is valid: false
Person{ssn=11111, givenName='Carl', surname='Unknown'}
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
...
</pre>

It is possible to add a custom validator by adding the method ''isValid()'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)

    public boolean isValid() {
        return ssn > 1000000;
    }
}
</pre>

...if we run the ''Main'' class again (don't forget to regenerate) we now get:
<pre>
1. Is valid: false
2. Is valid: false
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
...
</pre>

The reason is that ''ssn'' doesn't meet the validation criteria ''ssn > 1000000'' since ''ssn'' was set to ''11111''.


Validations can also be performed for substates, e.g:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState address;

    public boolean isValid() {
        return address.getStreetName().startsWith("A") && ssn > 1000000;
    }
}
</pre>

In this case the state will only be valid, and possible to encapsulate, if the street name starts with an "A":
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        boolean isValid1 = Person.ssn(10000000).givenName("Carl").address(Address.streetName("AStreet").streetNumber(1).zipcode(123)).isValid();
        boolean isValid2 = Person.ssn(10000000).givenName("Carl").address(Address.streetName("BStreet").streetNumber(1).zipcode(123)).isValid();

        System.out.println("isValid1: " + isValid1);
        System.out.println("isValid2: " + isValid2);
    }
}
</pre>

output:
<pre>
isValid1: true
isValid2: false
</pre>

It the ''isValid()'' method operates on an expanded substate, the state template class need to extend the ''StateImpl'' class:
<pre>
package com.myproject.state;

public class PersonStateTemplate extends PersonStateImpl {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState $address;

    public boolean isValid() {
        return streetName.startsWith("A") && ssn > 1000000;
    }
}
</pre>

Let's see what will happen if we add validations on both ''PersonState'' and ''AddressState'':
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;

    public boolean isValid() {
        return streetName.startsWith("A");
    }
}
</pre>

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState $address;

    public boolean isValid() {
        return ssn > 1000000;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        boolean isValid1 = Person.ssn(10000000).givenName("Carl").streetName("AStreet").streetNumber(1).zipcode(123).isValid();
        boolean isValid2 = Person.ssn(1).givenName("Carl").streetName("AStreet").streetNumber(1).zipcode(123).isValid();
        boolean isValid3 = Person.ssn(10000000).givenName("Carl").streetName("BStreet").streetNumber(1).zipcode(123).isValid();

        System.out.println("isValid1: " + isValid1);
        System.out.println("isValid2: " + isValid2);
        System.out.println("isValid3: " + isValid3);
    }
}
</pre>

output:

<pre>
isValid1: true
isValid2: false
isValid3: false
</pre>

As we can see both validation rules has to be met to give a valid result.
We can see that both validation rules are handled by generated class ''PersonStateImpl'':
<pre>
    ...

    private boolean isValid(boolean encapsulated) {
        if (givenName == null
           || streetName == null) {
            return false;
        }
        if (!isAddressValid()) {
            return false;
        }
        return ssn > 1000000;
    }

    private boolean isAddressValid() {
        return streetName.startsWith("A");
    }

    ...
</pre>

