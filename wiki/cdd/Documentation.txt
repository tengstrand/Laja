= Introduction =

Context Driven Development (CDD) takes a new approach to object orientation by separating ''state'' and ''behaviour''.
This allows us to work in different context without breaking encapsulation.
It's also the foundation that makes it possible to improve the way state is built and validated.
The problem is solved by using ''code generation''.
By using code generation, the amount of code needed to be written is reduced to a minimum which allows us to
focus more on ''what'' to do instead of ''how'' resulting in cleaner and more robust code.


If we take a look at the [[CDD_-_Getting_started|Getting started]] example, it has the following structure in the IDE:

[[File:project-directory-structure.png]]

The directory ''java-gen'' contains a lot of code generated classes, but don't worry (be happy!) they are here to make your development experience more pleasant!

If you are using a version control system you should put both ''java'' and ''java-gen'' under version control which will facilitate [http://en.wikipedia.org/wiki/Code_refactoring refactoring].


Let's explain some of the basic concepts of CDD by looking at three of the classes from the [[CDD_-_Getting_started|Getting started]] example:

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String givenName;
    String surname;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    public boolean isAdult() {
        return state.getAge() >= 18;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {

    public static void main(String[] args) {
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
        System.out.println("Is adult: " + person.isAdult());

        person.asPersistable().save();
    }
}
</pre>

output:
<pre>
Is adult: false
The state was saved: {age=15, givenName='Ingmar', surname='Bergman'}
</pre>


If we take a closer look at the statement that creates an instance of ''Person'':
<pre>
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
</pre>

...we can see that CDD starts by building ''state'' and ends with encapsulation by choosing a ''behaviour representation''.
In this example all attributes are mandatory and therefore included in the [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator]: ''age(15).givenName("Ingmar").surname("Bergman")''.
The attributes are defined in ''PersonStateTemplate'' which is the foundation that all generated code is based on, such as the ''chained constructor'', ''hashCode()'', ''equals()'' and ''toString()''.


The statement...
<pre>
        person.asPersistable().save();
</pre>

...switches context and persists the instance in one statement! This will be described in more detail later.

= Classes and objects =
In traditional object oriented languages the ''state'' and ''behaviour'' are merged to form classes that can be instantiated to objects:


[[File:Traditional-object.png|450px]]


The merging of state and behavior makes it harder to reuse code and to work in different contexts.
Languages with support for [http://en.wikipedia.org/wiki/Trait_%28computer_programming%29 traits] has enhanced flexibility at the class level but not at the instance/object level.


CDD wants to bring the same level of flexibility to objects as for classes.
The separation between ''state'' and ''behaviour'' enables powerful ways to build, validate and compose classes and objects.
It also makes it easy to work in different contexts:


[[File:CDD-object.png|500px]]


CDD is not the only attempt to improve the way of working with objects, you may also find interest in the [http://en.wikipedia.org/wiki/Data,_context_and_interaction DCI] paradigm.
The popular ''account example'' looks like [http://www.jroller.com/sebastianKuebeck/entry/object_oriented_programming_2_0 this] in DCI and like [https://github.com/tengstrand/Laja/blob/master/src/example/java/cdd/main/net/sf/laja/example/account/AccountExample.java this] in CDD.


An object (class instance) is in CDD has the following structure:
<br/>

[[File:CDD-object-layering.png|350px]]


This layering allows us to have a set of behaviour representations, one per task/context. The behaviour representation does not know how the state is stored which makes it possible to support a couple of
interesting techniques like [[#State expansion|state expansion]] and [[#State projection|state projection]] which facilitates composition and code reuse.

= State =
The decision to separate ''state'' and ''behavior'' enables us to improve the objects creation process by giving more love and care to it.
Instead of creating objects in ''one step'' by using a constructor, the object is created in ''several steps'' allowing for a range of improvements:
* The state is defined in a [http://en.wikipedia.org/wiki/Declarative_programming declarative] way so that ''equals'', ''hashCode'' and ''toString'' can be generated, letting you focus on the properties of each attribute.
* The [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator] and/or [http://en.wikipedia.org/wiki/Builder_pattern builder pattern] is used to build state which ''improves the readability'' and is more robust and flexible than a set of constructors (or even worse, an empty constructor with a bunch of [http://en.wikipedia.org/wiki/Mutator_method setters]!)
* Ensures valid state before encapsulation takes place.
* Ensures that the state can not be change from the outside once the state is encapsulated.
* The state can be validated before encapsulation takes place, which is handy when working with external data and user input.
* The encapsulation step can be postponed allowing delegation of validation and encapsulation to the caller.


The states is defined in ''state templates'' which is ordinary Java classes that is checked at compile time the same way as all other code.
This approach makes the state definition more robust than having them in an ordinary text file format like XML.
The templates is expected to be found in directory ''srcDir'', package ''statePackage'' in the project file, e.g. ''myproject.laja'':
<pre>
#generateCdd([{
  srcDir: "{.}/main"
  outDir: "{..}/java-gen/main"
  statePackage: "com.myproject.state"
  behaviourPackage: "com.myproject.behaviour" }]
)
</pre>

Example of valid state packages (in this example) are:
* com.myproject.state
* com.myproject.state.domain
* com.myproject.state.infrastructure.x''


Let's extend ''PersonState'' by modifying the state template ''PersonStateTemplate'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int personId; // (id)
    int length; // (hide)
    long ssn; // (key)
    String givenName;
    String middleName; // (optional)
    String surname;
    String occupation; // (exclude)
}
</pre>

...regenerate and modify the main method:

<pre>
public class Main {
    public static void main(String[] args) {
        // The 'chained creator' starts here...
        Person person = Person.ssn(12345678).givenName("Ingmar").surname("Bergman")
                .withPersonId(1)                  // ...followed by builder methods
                .withMiddleName("Ernst")
                .withOccupation("Film director")
                .asPerson();                      // ...and encapsulation

        System.out.println(person);
    }
}
</pre>

...modify the constructor of ''Person'' (ensures that the hidden attribute ''length'' is set):
<pre>
    public Person(PersonState state) {
        super(state);
        state.setLength(179);
    }
</pre>

... gives the output:
<pre>
Person{personId=1, length=179, ssn=12345678, givenName='Ingmar', middleName='Ernst', surname='Bergman', occupation='Film director'}
</pre>


If we look at how the instance of ''Person'' is created, it follows this pattern:
* '''Chained creator''': contains all ''mandatory'' attributes using the pattern [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html Chained Creator].
* '''Builder methods''': all ''optional'' attributes, marked as ''(optional)'', ''(id)'' or ''(exclude)''. These methods are not mandatory and can be omitted.
* '''Encapsulation''': encapsulates the state by choosing a behaviour representation.


Each attribute can have one or several properties by ending the line with a comment. None of them are mandatory:

{| class="wikitable"
! Keyword !! Example !! Description
|-
|
(id)
||
<span style="color:#008000">int</span>&nbsp;personId;&nbsp;// (id)
||
The [http://en.wikipedia.org/wiki/Surrogate_key surrogate key]. Only one attribute can be marked as surrogate key.
|-
|
(key)
||
<span style="color:#008000">long</span>&nbsp;ssn;&nbsp;//&nbsp;(key)
||
The [http://en.wikipedia.org/wiki/Natural_key natural key]. One or several attributes can be included in the natural key.
|-
|
(optional)
||
<span style="color:#008000">String</span>&nbsp;middleName;&nbsp;//&nbsp;(optional)
||
The keywords ''(optional)'', ''(id)'' and ''(exclude)'' will exclude the attribute from the ''chained creator'' allowing them to be uninitialized (''null'').
|-
|
(hide)
||
<span style="color:#008000">int</span> length; // (hide)
||
The ''hide'' keyword excludes the attribute from the ''chained creator'' but requires it to be initialized (''not null'') by the constructor of the ''behaviour'' class, if not combined with the ''(optional)'' keyword.
|-
|
(exclude)
||
<span style="color:#008000">String</span> occupation; // (exclude)
||
Same as ''optional'' except that it's excluded from ''hashCode()'' and ''equals()''.
|}


If all attributes are optional, then the chained creator can be accessed via the ''create()'' method, example:
<pre>
Person person = Person.create().withAge(16).asPerson();
</pre>

== Identity ==
In [http://en.wikipedia.org/wiki/Domain-driven_design Domain Driven Design] the state objects are categorized in two groups, ''values'' and ''entities''.
If no attribute is marked as ''natural key'' causes CDD consider the state as a ''value'', example:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }
}
</pre>

The inheritance hierarchy of Person goes like this: ''PersonFactory'' > ''PersonValueFactory'' > ''PersonValue'' where PersonValue includes both ''givenName'' and ''surname'' in ''hashCode()'' and ''equals()''.

'''Rule''': All attributes except ''(id)'' and ''(exclude)'', are included in ''hashCode()'' and ''equals()'' for values.


If we add a [http://en.wikipedia.org/wiki/Natural_key natural key] to ''PersonState'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName; // (key)
    String surname;
}
</pre>

...the inheritance hierarchy is changed to: ''PersonFactory'' > ''PersonEntityFactory'' > ''PersonEntity'' where the PersonEntity includes only ''givenName'' in ''hashCode()'' and ''equals()''.

'''Rule''': Only the ''natural key'' is included in ''hashCode()'' and ''equals()'' for entities.

'''Rule''': If one or more attribute is marked as ''natural key'' the state will be implemented as an ''entity'', otherwise as a ''value''.

=== Context dependent identity ===
A tricky part in object orientation is the management of ''identity''.
The problem in traditional OO is that we need to decide if a class should be treated as a ''value'' or an ''entity''.
A better solution would be to support both value based and entity based representation by allowing [http://natureofcode.blogspot.se/2011/08/exploring-nature-of-code.html context switching].
As a surprise, this is just what CDD allows us to do!

If we include ''ssn'' in the ''natural key'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
}
</pre>

...we can see that only ''ssn'' is included in ''hashCode()'' and ''equals()'':

<pre>
public class PersonStateImpl implements PersonState {
    ...

    @Override
    public int hashCode() {
        int result = (int)ssn;

        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PersonStateImpl state = (PersonStateImpl)o;

        if (ssn != state.getSsn()) return false;

        return true;
    }

    ...
}
</pre>

This is the desired behaviour in most situations when working against a persistence layer.
In our test code, however, we may be interested in comparing all attributes in some situations.

In traditional OO we need to treat ''Person'' as either ''entity'' or ''value'' while in CDD you can have several representations and switch between them.


Let's demonstrate how we can create the value based representation ''OtherPerson'' and switch context between the entity based ''Person'' and ''OtherPerson'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class OtherPerson extends PersonValue {
    public OtherPerson(PersonState state) {
        super(state);
    }
}
</pre>

To make this class a ''value'' we extend from (the code generated) ''PersonValue'' which has the following implementation of ''hashCode'' and ''equals'':
<pre>
    ...

    @Override
    public int hashCode() {
        return state.valueHashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;

        return state.valueEquals(((PersonValue)o).state);
    }

    ...
</pre>

...which delegates to ''valueHashCode()'' and ''valueEquals()'' in the (code generated) class ''PersonStateImpl'':
<pre>
    ...

    public int valueHashCode() {
        int result = length;
        result = 31 * result + (int)ssn;
        result = 31 * result + (givenName != null ? givenName.hashCode() : 0);
        result = 31 * result + (middleName != null ? middleName.hashCode() : 0);
        result = 31 * result + (surname != null ? surname.hashCode() : 0);

        return result;
    }

    public boolean valueEquals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PersonStateImpl state = (PersonStateImpl)o;

        if (length != state.getLength()) return false;
        if (ssn != state.getSsn()) return false;
        if (givenName != null ? !givenName.equals(state.givenName) : state.givenName != null) return false;
        if (middleName != null ? !middleName.equals(state.middleName) : state.middleName != null) return false;
        if (surname != null ? !surname.equals(state.surname) : state.surname != null) return false;

        return true;
    }

    ...
</pre>

If we add the switch method ''asOtherPerson'' to ''Person'':
<pre>
    public OtherPerson asOtherPerson() {
        return new OtherPerson(state);
    }
</pre>

...and modify the ''main'' method in ''Main'':
<pre>
    public static void main(String[] args) {
        Person person1 = Person.ssn(111222).givenName("Ingmar").surname("Bergman").asPerson();
        Person person2 = Person.ssn(111222).givenName("Ingmar").surname("Johansson").asPerson();

        OtherPerson otherPerson1 = person1.asOtherPerson();
        OtherPerson otherPerson2 = person2.asOtherPerson();

        System.out.println("1. Equals: " + person1.equals(person2));
        System.out.println("2. Equals: " + otherPerson1.equals(otherPerson2));
    }
</pre>

..we get the output:
<pre>
1. Equals: true
2. Equals: false
</pre>

We can see that the class ''Person'' treats ''person1'' and ''person2'' as equal because they have the same value of ''ssn'' but seen as different when wrapped by ''OtherPerson'' since ''surname'' differs.

By switching context from ''Person'' to ''OtherPerson'' we are not stuck comparing only ''ssn'' but can make a "full comparison" between two instances without breaking encapsulation.

== Type converters ==
Sometimes we want an attribute to support more than one type. To add that support we need to add a converter:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn;
    String givenName;
    String surname;

    int convertSsn(String ssn) {
        return Integer.valueOf(ssn);
    }
}
</pre>

This little trick allow us to select between ''int'' and ''String'' when giving the attribute ''ssn'':

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person ingmar = Person.ssn(123).givenName("Ingmar").surname("Bergman").asPerson();
        Person lars = Person.ssn("456").givenName("Lars").surname("von Trier").asPerson();

        System.out.println(ingmar);
        System.out.println(lars);
    }
}
</pre>

...gives the output:
<pre>
Person{ssn=123, givenName='Ingmar', surname='Bergman'}
Person{ssn=456, givenName='Lars', surname='von Trier'}
</pre>

The ''ssn'' is in both cases stored as ''int'' which was specified in the state template.

== State composition ==
CDD supports composition referred to as ''aggregate roots'' in [http://en.wikipedia.org/wiki/Domain-driven_design DDD].
This is best explained by adding ''AddressState'':
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;
}
</pre>

...regenerate and add it to ''PersonState'' (the attribute should be named ''address'' not ''addressState''):
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
    AddressState address;
}
</pre>

...regenerate and change ''Main'':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").surname("Bergman").address(
                Address.streetName("Main Street").streetNumber(123).zipcode(111222)).asPerson();

        System.out.println(person);
    }
}
</pre>

...gives the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Bergman', address={streetName='Main Street', streetNumber=123, zipcode=111222}}
</pre>

Substates can include other substates by for example letting ''AddressSate'' include ''ZipcodeState'' but we leave this exercise to the reader!

== State expansion ==
Substates can be "expanded" and merged into the state. A dollar sign ($) marks a substate for expansion:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
    AddressState $address;
}
</pre>

...if we regenerate we can change ''Main'':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").surname("Bergman")
                .streetName("Main Street").streetNumber(123).zipcode(111222).asPerson();

        System.out.println(person);
    }
}
</pre>

...which gives the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Bergman', streetName='Main Street', streetNumber=123, zipcode=111222}
</pre>

As we can see, the attributes from ''AddressState'' has been "exploded" and merged into ''PersonState''.
If we take a look at ''PersonState'' it now extends ''AddressState'':
<pre>
...

public interface PersonState extends AddressState {
    ...
}
</pre>

...this will make it possible to wrap both ''Person'' and ''Address'' behaviour around ''PersonState'', more on that later.

If Laja finds two or more attributes with the same type and name they will be merged into a single attribute ''without any warnings''.
This is not how it should work and will be changed in a future release!

== State projection ==
If we have the states ''A'' and ''B'', then we can use ''state projection'' to let ''B'' act as an ''A''.
This can be useful if ''B'' contains all the attributes that ''A'' has but the object structure or the attribute names differs.
State projection should only be used when [[#State expansion|state expansion]] is not possible.


Let's say we define these three states:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String givenName;
    String surname;
    AddressState $address;
}
</pre>

<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
}
</pre>

<pre>
package com.myproject.state;

public class StrangePersonStateTemplate {
    int ageInYears;
    String firstName;
    String secondName;
    AddressState address;
}
</pre>

The attributes in ''StrangePersonState'' doesn't match the attributes in ''PersonState'':
* ''address'' is expanded in ''PersonState'' but not in  ''StrangePersonState''.
* The name of the attributes doesn't match.

We can let ''StrangePersonState'' act as a ''PersonState'' by adding a state projection method:
<pre>
package com.myproject.state;

public class StrangePersonStateTemplate {
    int ageInYears;
    String firstName;
    String secondName;
    AddressState address;

    PersonStateProjection statePerson() {
        return PersonStateProjection
            .age(ageInYears)
            .givenName(firstName)
            .surname(secondName)
            .streetName(address.getStreetName())
            .streetNumber(address.getStreetNumber());
    }
}
</pre>

The method has to return an instance of the ''StateProjection'' it is going to act as and the method name must start with "state" followed by an upper case letter.
When generated, the interface ''StrangePersonState'' will have the method ''getPersonState()'' returning a ''PersonState'', to be used from e.g. ''StrangePerson'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.StrangePersonState;

public class StrangePerson extends StrangePersonFactory {
    private Person person;

    public StrangePerson(StrangePersonState state) {
        super(state);
        person = new Person(state.getPersonState());
    }

    // (factory)
    public StrangePerson asStrangePerson() {
        return new StrangePerson(state);
    }

    public boolean isAdult() {
        return person.isAdult();
    }
}
</pre>

The current alpha version lacks some functionality that will be added in a future version:
* The types of the mapping attributes has to match, casting or converting types is not supported.
* Some restrictions in how the object structure (substates) can be mapped.

== Default values ==
Attributes can be set to default values, e.g.:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname = "Unknown"; // (optional)
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").asPerson();

        System.out.println(person);
    }
}
</pre>

output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Unknown'}
</pre>

== Build state ==
So far we have used ''chained creators'' to build state. Sometimes you don't have access to all mandatory attributes from start. In these situations you need a ''builder'' which is accessed via the method ''build()'':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.build()
                .withGivenName("Ingmar")
                .withSsn(11111)
                .withSurname("Bergman").asPerson();

        System.out.println(person);
    }
}
</pre>
output:
<pre>
Person{ssn=11111, givenName='Ingmar', surname='Bergman'}
</pre>


The attributes can occur in arbitrary order and some or all attributes can be left out:
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.build().asPerson();
    }
}
</pre>

output:
<pre>
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
	at com.myproject.behaviour.PersonEntityFactory$PersonFactory_.create(PersonEntityFactory.java:35)
	at com.myproject.state.PersonStateBuilderImpl.as(PersonStateBuilderImpl.java:51)
	at com.myproject.behaviour.PersonBuilder.asPerson(PersonBuilder.java:37)
	at com.myproject.behaviour.Main.main(Main.java:5)
	...
</pre>

As you can see, it's not possible to create instances if the state is invalid. In this case we have missed to set the mandatory attributes ''ssn'' and ''givenName''.
With a ''builder'' you can't guarantee, in compile time, that all mandatory attribute has been set and that's the main reason why a ''chained creator'' is the preferable choice in most situations.

== Validate state ==

The state can be validated before the state is encapsulated:

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        PersonEncapsulator personEncapsulator = Person.ssn(11111).givenName("Carl");
        PersonBuilder personBuilder = Person.build();

        System.out.println("1. Is valid: " + personEncapsulator.isValid());
        System.out.println("2. Is valid: " + personBuilder.isValid());
    }
}
</pre>

<pre>
1. Is valid: true
2. Is valid: false
Person{ssn=11111, givenName='Carl', surname='Unknown'}
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
...
</pre>

=== Custom validation ===

It is possible to add a custom validation by adding the method ''isValid()'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)

    public boolean isValid() {
        return ssn > 1000000;
    }
}
</pre>

...if we run the ''Main'' class again (don't forget to regenerate) we now get:
<pre>
1. Is valid: false
2. Is valid: false
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
...
</pre>

The reason is that ''ssn'' doesn't meet the validation rule ''ssn > 1000000'' since ''ssn'' was set to ''11111''.


Validations can also be performed for substates, e.g:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState address;

    public boolean isValid() {
        return address.getStreetName().startsWith("A") && ssn > 1000000;
    }
}
</pre>

In this case the state will only be valid, and possible to encapsulate, if the street name starts with an 'A':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        boolean isValid1 = Person.ssn(10000000).givenName("Carl").address(Address.streetName("AStreet").streetNumber(1).zipcode(123)).isValid();
        boolean isValid2 = Person.ssn(10000000).givenName("Carl").address(Address.streetName("BStreet").streetNumber(1).zipcode(123)).isValid();

        System.out.println("isValid1: " + isValid1);
        System.out.println("isValid2: " + isValid2);
    }
}
</pre>

output:
<pre>
isValid1: true
isValid2: false
</pre>

If the ''isValid()'' method operates on an expanded substate, the state template class need to extend the ''StateImpl'' class:
<pre>
package com.myproject.state;

public class PersonStateTemplate extends PersonStateImpl {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState $address;

    public boolean isValid() {
        return streetName.startsWith("A") && ssn > 1000000;
    }
}
</pre>


We could also have added validations on both ''PersonState'' and ''AddressState'':
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;

    public boolean isValid() {
        return streetName.startsWith("A");
    }
}
</pre>

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState $address;

    public boolean isValid() {
        return ssn > 1000000;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        boolean isValid1 = Person.ssn(10000000).givenName("Carl").streetName("AStreet").streetNumber(1).zipcode(123).isValid();
        boolean isValid2 = Person.ssn(1).givenName("Carl").streetName("AStreet").streetNumber(1).zipcode(123).isValid();
        boolean isValid3 = Person.ssn(10000000).givenName("Carl").streetName("BStreet").streetNumber(1).zipcode(123).isValid();

        System.out.println("isValid1: " + isValid1);
        System.out.println("isValid2: " + isValid2);
        System.out.println("isValid3: " + isValid3);
    }
}
</pre>

output:

<pre>
isValid1: true
isValid2: false
isValid3: false
</pre>

As we can see, both validation rules must be valid. We can verify that both validation rules are performed by taking a look in the generated class ''PersonStateImpl'':
<pre>
    ...

    private boolean isValid(boolean encapsulated) {
        if (givenName == null
           || streetName == null) {
            return false;
        }
        if (!isAddressValid()) {
            return false;
        }
        return ssn > 1000000;
    }

    private boolean isAddressValid() {
        return streetName.startsWith("A");
    }

    ...
</pre>

= Behaviour =

We have finally reached the point where it's time to add some behavior. Developing a system without behavior would nevertheless be quite pointless!
Context Driven Development (CDD) makes it easy to add behaviour and let you build your system in a way similar to building with Lego.


In CDD we can have different representations for each context, allowing us to put each behaviour in the right place.
In the [[CDD_-_Getting_started|Getting started]] section we let ''Person'' work in the core domain and ''PersistablePerson'' be responsible for persisting:
<pre>
package com.myproject.behaviour;

public class Main {

    public static void main(String[] args) {
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
        System.out.println("Is adult: " + person.isAdult());

        person.asPersistable().save();
    }
}
</pre>

In traditional [http://en.wikipedia.org/wiki/Object-oriented_programming OO] the code above would have evolved something like this:
# Create the "core domain " class ''Person'' with the behaviour method ''isAdult'' (with no getters or setters).
# After a while we need to do something with ''Person'' outside the core domain like ''export as XML'' or ''persist''. This presents us with two bad alternatives:
#* Add the method ''asXml()'' or ''save()'' to ''Person'' braking the [http://en.wikipedia.org/wiki/Single_responsibility_principle single responsibility principle].
#* Add some getters to ''Person'' and delegate the work to e.g. ''PersonXmlExporter'' or ''PersonPersisterService'' leading to violation of the [http://c2.com/cgi/wiki?TellDontAsk Tell Don't Ask] principle (*).


CDD respects these two principles by allowing you to work in different contexts!

(*) The ''Tell Don't Ask principle'' is about letting the objects themselves perform tasks.

== Context switching ==

In the listing above we ''switched context'' in order to perform the save operation:
<pre>
        person.asPersistable().save();
</pre>


The switching is performed by the method ''asPersistable()'':

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</pre>


Being able to switch context is not just a way of splitting up behavior between objects,
it's also a way to reduce the amount of code needed to integrate different parts of the system.

Context switching can both mean switching task ''within'' an architectural layer as well as switching task to ''another'' architectural layer:

<pre>
              /\
              |
              |   architectural layers
              |
   <--- switch tasks --->
              |
              |
              |
              \/

(this ascii art will be replaced by a picture)
</pre>

Switching context has never been easier!

== Factory ==

In our example we have used ''Person'' as factory when creating instances of ''Person''. We could also have used the generated class ''PersonFactory'':
<pre>
    Person person1 = PersonFactory.givenName("Ingmar").surname("Bergman").asPerson();
    Person person2 = PersonFactory.build().withGivenName("Ingmar").withSurname("Bergman").asPerson();
</pre>

To make ''Person'' a factory we extend from ''PersonFactory'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</pre>

Only the method that is marked as ''factory'' can be directly created by the factory class. If an "as-method" is not marked as factory then it has to be called via the factory method:
<pre>
    PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPerson().asPersistable();
</pre>

If we also mark ''asPersistable'' as factory:
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</pre>

...we can create instances directly:
<pre>
    PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPersistable();
</pre>


In some situations we want the object themselves to act as factory:
<pre>
    Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
    PersistablePerson persistablePerson = PersistablePerson.givenName("Ingmar").surname("Bergman").asPersistable();
</pre>

...by letting the behaviour class inherit from its factory and include a factory method:

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // Behaviour is added here...
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class PersistablePerson extends PersistablePersonFactory {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    // Behaviour is added here...
}
</pre>


It's not mandatory to pick a behaviour class and use it as a factory, like we did with ''Person'' and ''PersistablePerson'', we could just as easily have used ''PersonFactory'' and ''PersistablePersonFactory''.
So why should we bother doing the extra work it means to inherit from the factory?
The reason is that we want to express the concept "person" and improve the readability:
 <pre>
    Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
 </pre>
...even though ''Person'' is just one behaviour representation among others it's a natural representative of the concept "person" and a good candidate for the factory role.


If you don't want a behaviour representation act as a factory you have to inherit from either (e.g.) ''PersonValue'' or ''PersonEntity'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonEntity;
import com.myproject.state.PersonState;

public class PersistablePerson extends PersonEntity {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // ...
}
</pre>


If the state template definition (''PersonStateTemplate'' in this case) includes a ''natural key'' (keyword "(key)") both the ''value'' and the ''entity'' class is generated,
otherwise only the ''value'' class is generated. If you remove the ''natural key'' from e.g. ''PersonStateTemplate'' you need to manually remove ''PersonEntity'' and all related ''PersonEntityFactory'' classes.


When a state template, e.g. ''PersonStateTemplate'', is created and regenerated for the first time, a couple of other classes is also generated.
The class ''Person'' is generated and put under the (non-generated) ''java'' directory structure and ''PersonFactory'' is generated and put under the ''java-gen'' structure.


If we don't need the behaviour representation ''Person'' we can just delete or rename it.


<span id="create_factory_in_two_steps"></span>
If we add another representation and don't want to put the factory method in ''Person'' we need to create it in two steps by first inherit from ''PersonValue'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class XmlPerson extends PersonValue {
    public XmlPerson(PersonState state) {
        super(state);
    }

    // (factory)
    public XmlPerson asXmlPerson() {
        return new XmlPerson(state);
    }
}
</pre>

...regenerate and then inherit from (the newly created) ''XmlPersonFactory'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class XmlPerson extends XmlPersonFactory {
    public XmlPerson(PersonState state) {
        super(state);
    }

    // (factory)
    public XmlPerson asXmlPerson() {
        return new XmlPerson(state);
    }
}
</pre>

=== Populate state ===
Sometimes one or more attributes are associated with the behaviour representation, indicated by the keyword "hide":
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String hairColor; // (hide)
    String givenName;
    String surname;
}
</pre>

In this case the ''hairColor'' should be populated by the behaviour representations. We start by adding the class ''GreyHairedPerson'' (don't forget to create it in [[#create_factory_in_two_steps|two steps]]):
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class GreyHairedPerson extends GreyHairedPersonFactory {
    public GreyHairedPerson(PersonState state) {
        super(state);
        state.setHairColor("Grey");
    }

    // (factory)
    public GreyHairedPerson asGreyHairedPerson() {
        return new GreyHairedPerson(state);
    }
}
</pre>

...we also add a class for red haired people:
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class RedHairedPerson extends RedHairedPersonFactory {
    public RedHairedPerson(PersonState state) {
        super(state);
        state.setHairColor("Red");
    }

    // (factory)
    public RedHairedPerson asRedHairedPerson() {
        return new RedHairedPerson(state);
    }
}
</pre>
...when executing:

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        GreyHairedPerson hans = GreyHairedPerson.givenName("Hans").surname("Alfredson").asGreyHairedPerson();
        RedHairedPerson tage = RedHairedPerson.givenName("Tage").surname("Danielsson").asRedHairedPerson();

        System.out.println(hans);
        System.out.println(tage);
    }
}
</pre>

...we get the output:
<pre>
GreyHairedPerson{hairColor='Grey', givenName='Hans', surname='Alfredson'}
RedHairedPerson{hairColor='Red', givenName='Tage', surname='Danielsson'}
</pre>

=== Populate substate ===
If you for some reason need to populate a substate, and if it can't be done by the corresponding behaviour class (''Address'' in this example), it can be managed by the aggregate root itself (''Person''):
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode; // (hide)
}
</pre>

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
    AddressState address;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.AddressState;

public class Address extends AddressFactory {
    public Address(AddressState state) {
        super(state);
    }

    // (factory)
    public Address asAddress() {
        return new Address(state);
    }
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonStateBuilder;

public class Person extends PersonFactory {
    public Person(PersonState state, PersonStateBuilder stateBuilder) {
        super(state, stateBuilder);

        // Populate attribute "zipcode" in substate "address".
        stateBuilder.getAddressStateBuilder().withZipcode(123);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state, stateBuilder);
    }
}
</pre>

If we run our "test program":
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.givenName("Ingmar").surname("Bergman").address(Address.streetName("Thestreet").streetNumber(1)).asPerson();

        System.out.println(person);
    }
}
</pre>

...the zipcode has been set to 123:
<pre>
Person{givenName='Ingmar', surname='Bergman', address={streetName='Thestreet', streetNumber=1, zipcode=123}}
</pre>


We can choose between two constructors when implementing our behaviour representations, e.g.:
<pre>
    public Person(PersonState state)
    public Person(PersonState state, PersonStateBuilder stateBuilder)
</pre>

The first is the most common and used when the state is not changed by the behaviour class and the second if we need to populate one or more substates.
Only one of the two constructors should be implemented at a time.
