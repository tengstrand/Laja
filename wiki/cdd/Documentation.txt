= Introduction =

Context Driven Development (CDD) takes a new approach to object orientation by separating ''state'' and ''behaviour''.
This allows us to work in different context without breaking encapsulation.
It's also the foundation that makes it possible to improve the way state is built and validated.
The problem is solved by using ''code generation''.
By using code generation, the amount of code needed to be written is reduced to a minimum which allows us to
focus more on ''what'' to do instead of ''how'' resulting in cleaner and more robust code.


If we take a look at the [[CDD_-_Getting_started|Getting started]] example, it has the following structure in the IDE:

[[File:project-directory-structure.png]]

The directory ''java-gen'' contains a lot of code generated classes, but don't worry (be happy!) they are here to make your development experience more pleasant!

If you are using a version control system you should put both ''java'' and ''java-gen'' under version control which will facilitate [http://en.wikipedia.org/wiki/Code_refactoring refactoring].


Let's explain some of the basic concepts of CDD by looking at three of the classes from the [[CDD_-_Getting_started|Getting started]] example:

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String givenName;
    String surname;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    public boolean isAdult() {
        return state.getAge() >= 18;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {

    public static void main(String[] args) {
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
        System.out.println("Is adult: " + person.isAdult());

        person.asPersistable().save();
    }
}
</pre>

output:
<pre>
Is adult: false
The state was saved: {age=15, givenName='Ingmar', surname='Bergman'}
</pre>


If we take a closer look at the statement that creates an instance of ''Person'':
<pre>
        Person person = Person.age(15).givenName("Ingmar").surname("Bergman").asPerson();
</pre>

...we can see that CDD starts by building ''state'' and ends with encapsulation by choosing a ''behaviour representation''.
In this example all attributes are mandatory and therefore included in the [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator]: ''age(15).givenName("Ingmar").surname("Bergman")''.
The attributes are defined in ''PersonStateTemplate'' which is the foundation that all generated code is based on, such as the ''chained constructor'', ''hashCode()'', ''equals()'' and ''toString()''.


The statement...
<pre>
        person.asPersistable().save();
</pre>

...switches context and persists the instance in one statement! This will be described in more detail later.

= Classes and objects =
In traditional object oriented languages the ''state'' and ''behaviour'' are merged to form classes that can be instantiated to objects:


[[File:Traditional-object.png|450px]]


The merging of state and behavior makes it harder to reuse code and to work in different contexts.
Languages with support for [http://en.wikipedia.org/wiki/Trait_%28computer_programming%29 traits] is able to compose classes in a powerful way, but once instantiated the objects become quite static in its nature.


CDD wants to bring the same level of flexibility to objects as for classes.
The decoupling of ''state'' and ''behaviour'' enables powerful ways to build, validate and compose classes and objects.
It also makes it easy to switch between contexts:


[[File:CDD-object.png|500px]]


CDD is not the only attempt to improve the way of working with objects, you may also find interest in the [http://en.wikipedia.org/wiki/Data,_context_and_interaction DCI] paradigm.
The popular ''account example'' looks like [http://www.jroller.com/sebastianKuebeck/entry/object_oriented_programming_2_0 this] in DCI and like [https://github.com/tengstrand/Laja/blob/master/src/example/java/cdd/main/net/sf/laja/example/account/AccountExample.java this] in CDD.


An object is divided into state and behaviour and is looser coupled than "traditional OO". The context is switched by selecting another behaviour:


[[File:CDD-object-layering.png|800px]]


The state is also very modular and can be created in several ways:


[[File:CDD-state-layering.png|800px]]

= State =
The decision to separate ''state'' and ''behavior'' allow us to focus more on the state creation process.
Instead of creating an object in ''one step'' by using a constructor, the object is created in ''several steps'' which gives the following advantages:
* The state is defined in a [http://en.wikipedia.org/wiki/Declarative_programming declarative] way so that ''equals'', ''hashCode'' and ''toString'' can be generated, letting us focus on the properties of each attribute.
* The [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html chained creator] and/or [http://en.wikipedia.org/wiki/Builder_pattern builder pattern] is used to build state which ''improves the usability'' compared to a set of constructors (or even worse, an empty constructor with a bunch of [http://en.wikipedia.org/wiki/Mutator_method setters]!)
* Ensures valid state before encapsulation takes place.
* Ensures that the state can not be change from the outside once the state is encapsulated.
* The state can be validated before encapsulation takes place, which is handy when working with data that we can't trust like and user input and external data.
* The encapsulation step can be postponed so that validation and encapsulation can be performed by the caller.


The states is defined in ''state templates'' which is ordinary Java classes that can be compiled and type checked like any other code.
This approach makes the state definition cleaner and more robust than having them in an ordinary text file format like XML.
The templates is expected to be found in directory ''srcDir'', package ''statePackage'' in the project file, e.g. ''myproject.laja'':
<pre>
#generateCdd([{
  srcDir: "{.}/main"
  outDir: "{..}/java-gen/main"
  statePackage: "com.myproject.state"
  behaviourPackage: "com.myproject.behaviour" }]
)
</pre>

Example of valid state packages (in this example) are:
* com.myproject.state
* com.myproject.state.domain
* com.myproject.state.infrastructure.x''


Let's extend ''PersonState'' by modifying the state template ''PersonStateTemplate'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int personId; // (id)
    int length; // (hide)
    long ssn; // (key)
    String givenName;
    String middleName; // (optional)
    String surname;
    String occupation; // (exclude)
}
</pre>

...regenerate and modify the main method:

<pre>
public class Main {
    public static void main(String[] args) {
        // The 'chained creator' starts here...
        Person person = Person.ssn(12345678).givenName("Ingmar").surname("Bergman")
                .withPersonId(1)                  // ...followed by builder methods
                .withMiddleName("Ernst")
                .withOccupation("Film director")
                .asPerson();                      // ...and encapsulation

        System.out.println(person);
    }
}
</pre>

...modify the constructor of ''Person'' (ensures that the hidden attribute ''length'' is set):
<pre>
    public Person(PersonState state) {
        super(state);
        state.setLength(179);
    }
</pre>

... gives the output:
<pre>
Person{personId=1, length=179, ssn=12345678, givenName='Ingmar', middleName='Ernst', surname='Bergman', occupation='Film director'}
</pre>


If we look at how the instance of ''Person'' is created, it follows these steps:
* '''Chained creator''': contains all ''mandatory'' attributes using the pattern [http://natureofcode.blogspot.se/2011/09/chained-creator-pattern.html Chained Creator].
* '''Builder methods''': all ''optional'' attributes, marked as ''(optional)'', ''(id)'' or ''(exclude)''. These methods are not mandatory and can be omitted.
* '''Encapsulation''': encapsulates the state by choosing a behaviour representation.


Each attribute can have one or several properties by ending the line with a comment. None of them are mandatory:

{| class="wikitable"
! Keyword !! Example !! Description
|-
|
(id)
||
<span style="color:#008000">int</span>&nbsp;personId;&nbsp;// (id)
||
The [http://en.wikipedia.org/wiki/Surrogate_key surrogate key]. Only one attribute can be marked as surrogate key.
|-
|
(key)
||
<span style="color:#008000">long</span>&nbsp;ssn;&nbsp;//&nbsp;(key)
||
The [http://en.wikipedia.org/wiki/Natural_key natural key]. One or several attributes can be included in the natural key.
|-
|
(optional)
||
<span style="color:#008000">String</span>&nbsp;middleName;&nbsp;//&nbsp;(optional)
||
The keywords ''(optional)'', ''(id)'' and ''(exclude)'' will exclude the attribute from the ''chained creator'' allowing them to be uninitialized (''null'').
|-
|
(hide)
||
<span style="color:#008000">int</span> length; // (hide)
||
The ''hide'' keyword excludes the attribute from the ''chained creator'' but requires it to be initialized (''not null'') by the constructor of the ''behaviour'' class, if not combined with the ''(optional)'' keyword.
|-
|
(exclude)
||
<span style="color:#008000">String</span> occupation; // (exclude)
||
Same as ''optional'' except that it's excluded from ''hashCode()'' and ''equals()''.
|}


If all attributes are optional, then the chained creator can be accessed via the ''create()'' method, example:
<pre>
Person person = Person.create().withAge(16).asPerson();
</pre>

== Identity ==
Identity is described as "''...the property of objects that distinguishes them from other objects''" in [http://en.wikipedia.org/wiki/Identity_%28object-oriented_programming%29 Wikipedia].
CDD divides stateful objects into two groups, ''values'' and ''entities''. The difference between the two is that values includes (almost) every attribute in the identity while entities only include the [http://en.wikipedia.org/wiki/Natural_key natural key].
You can think of the natural key as the attribute(s) that would be the [http://en.wikipedia.org/wiki/Primary_key#Defining_primary_keys primary key] in a database table if not using a [http://en.wikipedia.org/wiki/Surrogate_key surrogate key] (id/counter).
If a surrogate key is not specified then only the natural key is included in ''hashCode()'' and ''equals()''.
In some situations the surrogate key should also be included. This case is not handled by this alpha version of CDD but will be fixed in a future version.


Entities means the same in CDD and DDD while values ​​can be both mutable and [http://en.wikipedia.org/wiki/Immutable_object immutable] and therefore differs from [http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD value objects in DDD].
If no attribute in the state is marked as ''natural key'' it will be treated as a values, example:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }
}
</pre>

The inheritance hierarchy of Person goes like this: ''PersonFactory'' > ''PersonValueFactory'' > ''PersonValue'' where PersonValue includes both ''givenName'' and ''surname'' in ''hashCode()'' and ''equals()''.


If we add a [http://en.wikipedia.org/wiki/Natural_key natural key] to ''PersonState'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName; // (key)
    String surname;
}
</pre>

...the inheritance hierarchy is changed to: ''PersonFactory'' > ''PersonEntityFactory'' > ''PersonEntity'' where the PersonEntity includes only ''givenName'' in ''hashCode()'' and ''equals()''.


We can summarize with three rules:
* All attributes except ''(id)'' and ''(exclude)'', are included in ''hashCode()'' and ''equals()'' for values.
* Only the ''natural key'' is included in ''hashCode()'' and ''equals()'' for entities.
* If one or more attribute is marked as ''natural key'' the state is treated as an ''entity'', otherwise as a ''value''.

=== Context dependent identity ===
A problem in traditional OO is that we up front need to decide if a stateful class should be treated as a value or entity.
Instead of forcing us to make this decision, CDD allow us to have a set of behaviour representations where some can be values and others can be entities.

If we include ''ssn'' in the ''natural key'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
}
</pre>

...we can see that only ''ssn'' is included in ''hashCode()'' and ''equals()'':

<pre>
public class PersonStateImpl implements PersonState {
    ...

    @Override
    public int hashCode() {
        int result = (int)ssn;

        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PersonStateImpl state = (PersonStateImpl)o;

        if (ssn != state.getSsn()) return false;

        return true;
    }

    ...
}
</pre>

This is the desired behaviour in most situations when working against a persistence layer.
In for example the test code we sometimes are interested in comparing all attributes.


Let's demonstrate how we can treat a person state as both value and entity by introducing ''OtherPerson'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class OtherPerson extends PersonValue {
    public OtherPerson(PersonState state) {
        super(state);
    }
}
</pre>

To make this class a ''value'' we extend from (the code generated) ''PersonValue'' which has the following implementation of ''hashCode'' and ''equals'':
<pre>
    ...

    @Override
    public int hashCode() {
        return state.valueHashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;

        return state.valueEquals(((PersonValue)o).state);
    }

    ...
</pre>

...which delegates to ''valueHashCode()'' and ''valueEquals()'' in the (code generated) class ''PersonStateImpl'':
<pre>
    ...

    public int valueHashCode() {
        int result = length;
        result = 31 * result + (int)ssn;
        result = 31 * result + (givenName != null ? givenName.hashCode() : 0);
        result = 31 * result + (middleName != null ? middleName.hashCode() : 0);
        result = 31 * result + (surname != null ? surname.hashCode() : 0);

        return result;
    }

    public boolean valueEquals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        PersonStateImpl state = (PersonStateImpl)o;

        if (length != state.getLength()) return false;
        if (ssn != state.getSsn()) return false;
        if (givenName != null ? !givenName.equals(state.givenName) : state.givenName != null) return false;
        if (middleName != null ? !middleName.equals(state.middleName) : state.middleName != null) return false;
        if (surname != null ? !surname.equals(state.surname) : state.surname != null) return false;

        return true;
    }

    ...
</pre>

If we add the switch method ''asOtherPerson'' to ''Person'':
<pre>
    public OtherPerson asOtherPerson() {
        return new OtherPerson(state);
    }
</pre>

...and modify the ''main'' method in ''Main'':
<pre>
    public static void main(String[] args) {
        Person person1 = Person.ssn(111222).givenName("Ingmar").surname("Bergman").asPerson();
        Person person2 = Person.ssn(111222).givenName("Ingmar").surname("Johansson").asPerson();

        OtherPerson otherPerson1 = person1.asOtherPerson();
        OtherPerson otherPerson2 = person2.asOtherPerson();

        System.out.println("1. Equals: " + person1.equals(person2));
        System.out.println("2. Equals: " + otherPerson1.equals(otherPerson2));
    }
</pre>

...we get the output:
<pre>
1. Equals: true
2. Equals: false
</pre>

We can see that the entity ''Person'' treats ''person1'' and ''person2'' as equal because they have the same value of ''ssn'' but seen as different by the value ''OtherPerson'' since ''surname'' differs.

By switching context from ''Person'' to ''OtherPerson'' we are not stuck comparing only the ''natural key'' but can make a "full comparison" between two instances without breaking encapsulation!

== Type converters ==
Sometimes we want more than one way to populate an attribute. This can be achieved by adding a converter:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn;
    String givenName;
    String surname;

    int convertSsn(String ssn) {
        return Integer.valueOf(ssn);
    }
}
</pre>

This little trick allow us to select between ''int'' and ''String'' when giving the attribute ''ssn'':

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person ingmar = Person.ssn(123).givenName("Ingmar").surname("Bergman").asPerson();
        Person lars = Person.ssn("456").givenName("Lars").surname("von Trier").asPerson();

        System.out.println(ingmar);
        System.out.println(lars);
    }
}
</pre>

...gives the output:
<pre>
Person{ssn=123, givenName='Ingmar', surname='Bergman'}
Person{ssn=456, givenName='Lars', surname='von Trier'}
</pre>

The ''ssn'' is in both cases internally stored as ''int'' which is the type of the attribute.

== State composition ==
CDD uses [http://en.wikipedia.org/wiki/Object_composition composition], known as [http://en.wikipedia.org/wiki/Domain-driven_design#Building_blocks_of_DDD aggregate] in DDD, when building more complex objects:

[[File:CDD-state-composition.png|180px]]


This is best explained by and example:
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;
}
</pre>

...regenerate and add it to ''PersonState'', Note that the attribute ''address'' should not be named ''addressState'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
    AddressState address;
}
</pre>

...regenerate and execute:
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").surname("Bergman").address(
                Address.streetName("Main Street").streetNumber(123).zipcode(111222)).asPerson();

        System.out.println(person);
    }
}
</pre>

...gives the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Bergman', address={streetName='Main Street', streetNumber=123, zipcode=111222}}
</pre>

Substates can include other substates (including itself if representing a parent/child relationship). We could for example let ''AddressState'' include ''ZipcodeState'', but we leave that exercise to the reader!

== State expansion ==
Substates can be "expanded" and merged into the state (the light grey area represents the ''address'' in the following example):

[[File:CDD-state-expansion.png|250px]]


A dollar sign ($) marks a substate for expansion ($ is a valid character for variable names in Java!):
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname;
    AddressState $address;
}
</pre>

...if we regenerate and change ''main'':
<pre>
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").surname("Bergman")
                .streetName("Main Street").streetNumber(123).zipcode(111222).asPerson();

        System.out.println(person);
    }
</pre>

...we get the output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Bergman', streetName='Main Street', streetNumber=123, zipcode=111222}
</pre>

As we can see, the attributes from ''AddressState'' has been "exploded" and merged into ''PersonState''.
If we take a look at ''PersonState'' it now extends ''AddressState'':
<pre>
...

public interface PersonState extends AddressState {
    ...
}
</pre>

...this will allow us to use ''PersonState'' as an "Address" which will be explained more in detail later.


If two or more attributes have the same type and name, they will be merged into a single attribute ''without any warnings''.
This is not how it works in this alpha version but will be changed in a future release!

== State projection ==
In the [[#State composition|state composition]] section we illustrated state with different forms like circle, triangle and pentagon.
Looking at ''state'' as ''form'' turns out to be a useful mental model when describing how CDD works:

[[File:CDD-state-projection.png|300px]]

State projection allows a state to ''look like'' another state. In the illustration above we let A look like B.


It's possible to put together pieces from several states to form a new state:

[[File:CDD-state-multi-projection.png|300px]]


This technique can be useful if ''A'' contains all the attributes that ''B'' has but the object structure or the attribute names differs.
[[#State expansion|State expansion]] is preferable to ''state projection'' when possible because it's simpler and less complex.


Let's say we define these three states:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int age;
    String givenName;
    String surname;
    AddressState $address;
}
</pre>

<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
}
</pre>

<pre>
package com.myproject.state;

public class StrangePersonStateTemplate {
    int ageInYears;
    String firstName;
    String secondName;
    AddressState address;
}
</pre>

The attributes in ''StrangePersonState'' doesn't match the attributes in ''PersonState'':
* ''address'' is expanded in ''PersonState'' but not in  ''StrangePersonState''.
* The name of the attributes doesn't match.


We can let ''StrangePersonState'' take the form of ''PersonState'' by implementing a state projection method:
<pre>
package com.myproject.state;

public class StrangePersonStateTemplate {
    int ageInYears;
    String firstName;
    String secondName;
    AddressState address;

    PersonStateProjection statePerson() {
        return PersonStateProjection
            .age(ageInYears)
            .givenName(firstName)
            .surname(secondName)
            .streetName(address.getStreetName())
            .streetNumber(address.getStreetNumber());
    }
}
</pre>

The method has to return an instance of a ''StateProjection'' of the "destination state" (Person). The method must also start with "state" followed by an upper case letter.
When generated, the interface ''StrangePersonState'' will have the method ''getPersonState()'' returning a ''PersonState'', to be used from e.g. ''StrangePerson'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.StrangePersonState;

public class StrangePerson extends StrangePersonFactory {
    private Person person;

    public StrangePerson(StrangePersonState state) {
        super(state);
        person = new Person(state.getPersonState());
    }

    // (factory)
    public StrangePerson asStrangePerson() {
        return new StrangePerson(state);
    }

    public boolean isAdult() {
        return person.isAdult();
    }
}
</pre>

The current alpha version lacks some functionality that will be added in a future version:
* The types of the mapping attributes has to match, casting or type conversion is not supported.
* Some restrictions in how the object structure (substates) can be mapped.

== Default values ==
Attributes can be set to default values, e.g.:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname = "Unknown"; // (optional)
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.ssn(112233).givenName("Ingmar").asPerson();

        System.out.println(person);
    }
}
</pre>

output:
<pre>
Person{ssn=112233, givenName='Ingmar', surname='Unknown'}
</pre>

== Build state ==
So far we have used ''chained creators'' to build state.
In some situations, if you for example don't have control of in which order the attributes are going to be set,  a ''builder'' can be more convenient:
<pre>
    public static void main(String[] args) {
        Person person = Person.build()
                .withGivenName("Ingmar")
                .withSsn(11111)
                .withSurname("Bergman").asPerson();

        System.out.println(person);
    }
</pre>
output:
<pre>
Person{ssn=11111, givenName='Ingmar', surname='Bergman'}
</pre>


The attributes can occur in arbitrary order and some or all attributes can be left out:
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.build().asPerson();
    }
}
</pre>

output:
<pre>
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
	at com.myproject.behaviour.PersonEntityFactory$PersonFactory_.create(PersonEntityFactory.java:35)
	at com.myproject.state.PersonStateBuilderImpl.as(PersonStateBuilderImpl.java:51)
	at com.myproject.behaviour.PersonBuilder.asPerson(PersonBuilder.java:37)
	at com.myproject.behaviour.Main.main(Main.java:5)
	...
</pre>

As you can see, it's not possible to create instances if the state is invalid. In this case we have missed to set the mandatory attributes ''ssn'' and ''givenName''.
With a ''builder'' you can't guarantee, at compile time, that all mandatory attribute has been set.
That's also the main reason why a ''chained creator'' is the preferable choice in most situations.

== Validate state ==

The state can be validated before the state is encapsulated:

<pre>
    public static void main(String[] args) {
        PersonBuilder builder1 = Person.build().withSsn(11111).withGivenName("Carl");
        PersonBuilder builder2 = Person.build();

        System.out.println("1. Is valid: " + builder1.isValid());
        System.out.println("2. Is valid: " + builder2.isValid());

        Person person1 = builder1.asPerson();
        System.out.println(person1);
    }
</pre>

<pre>
1. Is valid: true
2. Is valid: false
Person{ssn=11111, givenName='Carl', surname='null'}
</pre>

=== Custom validation ===

It is possible to add a custom validation by adding the method ''isValid()'':
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)

    public boolean isValid() {
        return ssn > 1000000;
    }
}
</pre>

...if we run the ''Main'' class again (don't forget to regenerate) we now get:
<pre>
1. Is valid: false
2. Is valid: false
Exception in thread "main" java.lang.IllegalStateException: Illegal state, could not create behaviour class 'Person'
...
</pre>

The reason is that ''ssn'' doesn't meet the validation rule ''ssn > 1000000'' since ''ssn'' was set to ''11111''.


Validations can also be performed for substates, e.g:
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState address;

    public boolean isValid() {
        return address.getStreetName().startsWith("A") && ssn > 1000000;
    }
}
</pre>

In this case the state will only be valid, and possible to encapsulate, if the street name starts with an 'A':
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        boolean isValid1 = Person.ssn(10000000).givenName("Carl").address(Address.streetName("AStreet").streetNumber(1).zipcode(123)).isValid();
        boolean isValid2 = Person.ssn(10000000).givenName("Carl").address(Address.streetName("BStreet").streetNumber(1).zipcode(123)).isValid();

        System.out.println("isValid1: " + isValid1);
        System.out.println("isValid2: " + isValid2);
    }
}
</pre>

output:
<pre>
isValid1: true
isValid2: false
</pre>

If the ''isValid()'' method operates on an expanded substate, the state template class need to extend the ''StateImpl'' class:
<pre>
package com.myproject.state;

public class PersonStateTemplate extends PersonStateImpl {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState $address;

    public boolean isValid() {
        return streetName.startsWith("A") && ssn > 1000000;
    }
}
</pre>


We could also have added validations on both ''PersonState'' and ''AddressState'':
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode;

    public boolean isValid() {
        return streetName.startsWith("A");
    }
}
</pre>

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    int ssn; // (key)
    String givenName;
    String surname; // (optional)
    AddressState $address;

    public boolean isValid() {
        return ssn > 1000000;
    }
}
</pre>

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        boolean isValid1 = Person.ssn(10000000).givenName("Carl").streetName("AStreet").streetNumber(1).zipcode(123).isValid();
        boolean isValid2 = Person.ssn(1).givenName("Carl").streetName("AStreet").streetNumber(1).zipcode(123).isValid();
        boolean isValid3 = Person.ssn(10000000).givenName("Carl").streetName("BStreet").streetNumber(1).zipcode(123).isValid();

        System.out.println("isValid1: " + isValid1);
        System.out.println("isValid2: " + isValid2);
        System.out.println("isValid3: " + isValid3);
    }
}
</pre>

output:

<pre>
isValid1: true
isValid2: false
isValid3: false
</pre>

As we can see, both validation rules must be met, and if we take a look at the generated class ''PersonStateImpl'':
<pre>
    ...

    private boolean isValid(boolean encapsulated) {
        if (givenName == null
           || streetName == null) {
            return false;
        }
        if (!isAddressValid()) {
            return false;
        }
        return ssn > 1000000;
    }

    private boolean isAddressValid() {
        return streetName.startsWith("A");
    }

    ...
</pre>

...we can verify that both rules actually are included!

= Behaviour =

We have finally reached the point where it's time to talk about behavior. Developing a system without behavior would nevertheless be quite pointless!
With CDD you are very free to compose your objects in a way similar to building with Lego.


In traditional OO, when you have created a cohesive class with a clear responsibility, the problems begin when you need to do some work in a different context.
Lets say we create the class ''Person'' only containing methods related to the core domain. When you want to export an instance of ''Person'' as XML, you are facing two bad alternatives:
* Add the method ''asXml()'' to ''Person'' resulting in braking the [http://en.wikipedia.org/wiki/Single_responsibility_principle single responsibility principle].
* Add some getters to ''Person'' and delegate the work to e.g. ''PersonXmlExporter'' leading to broken encapsulation and violation of the [http://c2.com/cgi/wiki?TellDontAsk Tell Don't Ask] principle (*).


(*) The ''Tell Don't Ask principle'' is about letting the objects themselves perform tasks.

The good news is that you don't need to do any of these unwanted things and the solution is spelled ''context switching''.

== Context switching ==
In an earlier example we switched context to be able to perform the save operation:
<pre>
        person.asPersistable().save();
</pre>

The switching was performed by the method ''asPersistable()'':

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</pre>

Being able to switch context is not just a way of splitting up behavior between objects,
it's also a way to reduce the amount of code needed to integrate different parts of the system.


Context switching can both mean switching task ''within'' an architectural layer as well as switching task ''between'' architectural layers:

<pre>
              /\
              |
              |   architectural layers
              |
   <--- switch tasks --->
              |
              |
              |
              \/

(this ascii art will be replaced by a picture)
</pre>

Switching context has never been easier!

== Factory ==

In our example we have used ''Person'' as factory when creating instances of ''Person''. We could also have used the generated class ''PersonFactory'':
<pre>
    Person person1 = PersonFactory.givenName("Ingmar").surname("Bergman").asPerson();
    Person person2 = PersonFactory.build().withGivenName("Ingmar").withSurname("Bergman").asPerson();
</pre>

To make ''Person'' a factory we extend from ''PersonFactory'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</pre>

Only the method that is marked as ''factory'' can be directly created by the factory class. If an "as-method" is not marked as factory then it has to be called via the factory method:
<pre>
    PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPerson().asPersistable();
</pre>

If we also mark ''asPersistable'' as factory:
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }
}
</pre>

...we can create instances directly:
<pre>
    PersistablePerson persistablePerson = Person.givenName("Ingmar").surname("Bergman").asPersistable();
</pre>


In some situations we want the object themselves to act as factory:
<pre>
    Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
    PersistablePerson persistablePerson = PersistablePerson.givenName("Ingmar").surname("Bergman").asPersistable();
</pre>

...by letting the behaviour class inherit from its factory and include a factory method:

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class Person extends PersonFactory {
    public Person(PersonState state) {
        super(state);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state);
    }

    // Behaviour is added here...
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class PersistablePerson extends PersistablePersonFactory {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // (factory)
    public PersistablePerson asPersistable() {
        return new PersistablePerson(state);
    }

    // Behaviour is added here...
}
</pre>


It's not mandatory to pick a behaviour class and use it as a factory, like we did with ''Person'' and ''PersistablePerson'', we could just as easily have used ''PersonFactory'' and ''PersistablePersonFactory''.
So why should we bother doing the extra work it means to inherit from the factory?
The reason is that we want to express the concept "person" and improve the readability:
 <pre>
    Person person = Person.givenName("Ingmar").surname("Bergman").asPerson();
 </pre>
...even though ''Person'' is just one behaviour representation among others it's a natural representative of the concept "person" and a good candidate for the factory role.


If you don't want a behaviour representation act as a factory you have to inherit from either (e.g.) ''PersonValue'' or ''PersonEntity'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonEntity;
import com.myproject.state.PersonState;

public class PersistablePerson extends PersonEntity {
    public PersistablePerson(PersonState state) {
        super(state);
    }

    // ...
}
</pre>


If the state template definition (''PersonStateTemplate'' in this case) includes a ''natural key'' (keyword "(key)") both the ''value'' and the ''entity'' class is generated,
otherwise only the ''value'' class is generated. If you remove the ''natural key'' from e.g. ''PersonStateTemplate'' you need to manually remove ''PersonEntity'' and all related ''PersonEntityFactory'' classes.


When a state template, e.g. ''PersonStateTemplate'', is created and regenerated for the first time, a couple of other classes is also generated.
The class ''Person'' is generated and put under the (non-generated) ''java'' directory structure and ''PersonFactory'' is generated and put under the ''java-gen'' structure.


If we don't need the behaviour representation ''Person'' we can just delete or rename it.


<span id="create_factory_in_two_steps"></span>
If we add another representation and don't want to put the factory method in ''Person'' we need to create it in two steps by first inherit from ''PersonValue'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonValue;

public class XmlPerson extends PersonValue {
    public XmlPerson(PersonState state) {
        super(state);
    }

    // (factory)
    public XmlPerson asXmlPerson() {
        return new XmlPerson(state);
    }
}
</pre>

...regenerate and then inherit from (the newly created) ''XmlPersonFactory'':
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class XmlPerson extends XmlPersonFactory {
    public XmlPerson(PersonState state) {
        super(state);
    }

    // (factory)
    public XmlPerson asXmlPerson() {
        return new XmlPerson(state);
    }
}
</pre>

=== Populate state ===
Sometimes one or more attributes are associated with the behaviour representation, indicated by the keyword "hide":
<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String hairColor; // (hide)
    String givenName;
    String surname;
}
</pre>

In this case the ''hairColor'' should be populated by the behaviour representations. We start by adding the class ''GreyHairedPerson'' (don't forget to create it in [[#create_factory_in_two_steps|two steps]]):
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class GreyHairedPerson extends GreyHairedPersonFactory {
    public GreyHairedPerson(PersonState state) {
        super(state);
        state.setHairColor("Grey");
    }

    // (factory)
    public GreyHairedPerson asGreyHairedPerson() {
        return new GreyHairedPerson(state);
    }
}
</pre>

...we also add a class for red haired people:
<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;

public class RedHairedPerson extends RedHairedPersonFactory {
    public RedHairedPerson(PersonState state) {
        super(state);
        state.setHairColor("Red");
    }

    // (factory)
    public RedHairedPerson asRedHairedPerson() {
        return new RedHairedPerson(state);
    }
}
</pre>
...when executing:

<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        GreyHairedPerson hans = GreyHairedPerson.givenName("Hans").surname("Alfredson").asGreyHairedPerson();
        RedHairedPerson tage = RedHairedPerson.givenName("Tage").surname("Danielsson").asRedHairedPerson();

        System.out.println(hans);
        System.out.println(tage);
    }
}
</pre>

...we get the output:
<pre>
GreyHairedPerson{hairColor='Grey', givenName='Hans', surname='Alfredson'}
RedHairedPerson{hairColor='Red', givenName='Tage', surname='Danielsson'}
</pre>

=== Populate substate ===
If you for some reason need to populate a substate, and if it can't be done by the corresponding behaviour class (''Address'' in this example), it can be managed by the aggregate root itself (''Person''):
<pre>
package com.myproject.state;

public class AddressStateTemplate {
    String streetName;
    int streetNumber;
    int zipcode; // (hide)
}
</pre>

<pre>
package com.myproject.state;

public class PersonStateTemplate {
    String givenName;
    String surname;
    AddressState address;
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.AddressState;

public class Address extends AddressFactory {
    public Address(AddressState state) {
        super(state);
    }

    // (factory)
    public Address asAddress() {
        return new Address(state);
    }
}
</pre>

<pre>
package com.myproject.behaviour;

import com.myproject.state.PersonState;
import com.myproject.state.PersonStateBuilder;

public class Person extends PersonFactory {
    public Person(PersonState state, PersonStateBuilder stateBuilder) {
        super(state, stateBuilder);

        // Populate attribute "zipcode" in substate "address".
        stateBuilder.getAddressStateBuilder().withZipcode(123);
    }

    // (factory)
    public Person asPerson() {
        return new Person(state, stateBuilder);
    }
}
</pre>

If we run our "test program":
<pre>
package com.myproject.behaviour;

public class Main {
    public static void main(String[] args) {
        Person person = Person.givenName("Ingmar").surname("Bergman").address(Address.streetName("Thestreet").streetNumber(1)).asPerson();

        System.out.println(person);
    }
}
</pre>

...the zipcode has been set to 123:
<pre>
Person{givenName='Ingmar', surname='Bergman', address={streetName='Thestreet', streetNumber=1, zipcode=123}}
</pre>


We can choose between two constructors when implementing our behaviour representations, e.g.:
<pre>
    public Person(PersonState state)
    public Person(PersonState state, PersonStateBuilder stateBuilder)
</pre>

The first is the most common and used when the state is not changed by the behaviour class and the second if we need to populate one or more substates.
Only one of the two constructors should be implemented at a time.
